# Max C API Notes

## Memory management

see: <https://cycling74.com/forums/class_attr_float_array-question>

@Eric
In your getter methods I strongly suggest you use two great little functions:
atom_alloc() and atom_alloc_array()
So, you'd write something like:

```c
t_max_err a_amplitudes_get(t_oscil *x, void *attr, long *ac, t_atom **av)
{
    if (ac && av)
    {
        char alloc;
        if (atom_alloc_array(OSCIL_MAX_HARMS, ac, av, &alloc)) {
            return MAX_ERR_OUT_OF_MEM;
        }

        for (int i = 0; i < OSCIL_MAX_HARMS; i++) {
            atom_setfloat(*av + i, x->a_amplitudes[i]);
        }
    }
    return MAX_ERR_NONE;
}
```

It makes for more streamlined and easy to read code.
It is also less error-prone than having to use sysmem_newptr()

and see: <https://cycling74.com/forums/adding-persistent-data-to-a-external>

For this specific issue, there are a couple of functions defined in ext_obex.h:

```c
atom_alloc()
atom_alloc_array()
```

that are designed exactly to make this kind of code clearer to read and more robust.
For example, you could replace:

```c
t_max_err macpod_getvalueof(t_macpod *x, long *ac, t_atom **av) 
{     
    if (ac && av) {        
        if (*ac && *av) {             
            // memory has been passed in; use it.         
        } else {             
            *av = (t_atom *)getbytes(sizeof(t_atom) * 5);         
        }         
        *ac = 5;         
        atom_setlong(*av,     x->offset_rnd);         
        atom_setlong(*av + 1, x->dur);         
        atom_setlong(*av + 2, x->dur_rnd);         
        atom_setlong(*av + 3, x->del);         
        atom_setlong(*av + 4, x->del_rnd);     
    }     
    return MAX_ERR_NONE; 
}
```

with:

```c
t_max_err macpod_getvalueof(t_macpod *x, long *ac, t_atom **av) 
{  
    if (ac && av) {
        char alloc;
        t_max_err err = atom_alloc_array(5, ac, av, &alloc);
        if (err == MAX_ERR_NONE) {
            atom_setlong(*av, x->offset_rnd);
            atom_setlong(*av + 1, x->dur);
            atom_setlong(*av + 2, x->dur_rnd);
            atom_setlong(*av + 3, x->del);
            atom_setlong(*av + 4, x->del_rnd);
        }
        return err;
    }
    return MAX_ERR_NONE;
}
```

## Pattern of Use

### chapter 5: Atoms and Messages

```c

void myobject_printargs(t_myobject *x, t_symbol *s, long argc, t_atom *argv)
{
    long i;
    t_atom *ap;
    post("message selector is %s",s->s_name);
    post("there are %ld arguments",argc);
    // increment ap each time to get to the next atom
    for (i = 0, ap = argv; i < argc; i++, ap++) {
            switch (atom_gettype(ap)) {
        case A_LONG:
            post("%ld: %ld",i+1,atom_getlong(ap));
            break;
        case A_FLOAT:
            post("%ld: %.2f",i+1,atom_getfloat(ap));
            break;
        case A_SYM:
            post("%ld: %s",i+1, atom_getsym(ap)->s_name);
            break;
        default:
            post("%ld: unknown atom type (%ld)", i+1, atom_gettype(ap));
            break;
        }
    }
}
```

### chapter 10: Sending Messages, Calling Methods

#### setter and getter example

```c
typedef struct _myobject {
    t_object m_ob;
    long *m_data;
} t_myobject;

CLASS_ATTR_LONG(c, "size", 0, t_myobject, m_data);
CLASS_ATTR_ACCESSORS(c, "size", myobject_size_get, myobject_size_set);

t_max_err myobject_size_set(t_myobject *x, t_object *attr, long argc, t_atom *argv)
{
    long size = atom_getlong(argv);
    if (size < 0)       // bad size, don’t change anything
        return 0;
    if (x->m_data)
        x->m_data = (long *)sysmem_resizeptr((char *)x->m_data, size * sizeof(long));
    else    // first time alloc
        x->m_data = (long *)sysmem_newptr(size * sizeof(long));
return 0; }

t_max_err myobject_size_get(t_myobject *x, t_object *attr, long *argc, t_atom **argv)
{
char alloc;
long size = 0;
    atom_alloc(argc, argv, &alloc);
// allocate return atom
    if (x->m_data)
        size = sysmem_ptrsize((char *)x->m_data) / sizeof(long);  // calculate array size
       based on ptr size
    atom_setlong(*argv, size);
return 0; }

```

#### receiving notifications

The notify method can handle a variety of notifications (more documentation on this is coming soon!), but the one we're interested in is "attr_modified" – the notification type is passed to the notify method in the msg argument. Here is an example of a notify method that prints out the name of the attribute that has been modified. You could take any action instead. To obtain the name, we interpret the data argument to the notify method as an attribute object. As an attribute is a regular Max object, we can use object_method to send it a message. In the case we are sending the message getname to the attribute object to obtain its name.

```c
// Add the following to your class initialization so your notification method will be called:
class_addmethod(c, (method)myobject_notify, "notify", A_CANT, 0);

t_max_err myobject_notify(t_myobject *x, t_symbol *s, t_symbol *msg, void *sender, void *data)
{
    t_symbol *attrname;
    if (msg == gensym("attr_modified")) {     // check notification type
        // ask attribute object for name
        attrname = (t_symbol *)object_method((t_object *)data, gensym("getname"));
        object_post((t_object *)x, "changed attr name is %s", attrname->s_name); 
    }
    return 0; 
}
```

### chapter 13: Scripting the Patcher

see: [here](https://cycling74.com/sdk/max-sdk-8.2.0/chapter_scripting.html#chapter_scripting_objects)

#### the patcher

To obtain the name of the patcher and its file path (if any), obtain attribute values as shown below.

```c
void myobject_getmypatcher(t_myobject *x) {
    t_object *mypatcher;
    object_obex_lookup(x, gensym("#P"), &mypatcher);
    t_symbol *name = object_attr_getsym(patcher, gensym("name"));
    t_symbol *path = object_attr_getsym(patcher, gensym("filepath"));
}
```

#### Operating on the patcher

Here is a function that prints the class of every object (in a box) in a patcher containing an object.

```c
void myobject_printpeers(t_myobject *x)
{
    t_object *patcher, *box, *obj;
    object_obex_lookup(x, gensym("#P"), &patcher);
    for (box = jpatcher_get_firstobject(patcher); box; box = jbox_get_nextobject(box)) {
        obj = jbox_get_object(box);
            if (obj)
                post("%s",object_classname(obj)->s_name);
            else
                post("box with NULL object");
    }
}
```

#### creating objects

Creating objects in a patcher generally requires the use of a `Dictionary`, but there is a convenience function `newobject_sprintf()` that can be used to avoid some of the complexity.

```c
t_object *patcher, *toggle, *metro;
t_max_err err;
err = object_obex_lookup(x, gensym("#P"), &patcher);
toggle = newobject_sprintf(patcher, 
    "@maxclass toggle @patching_position %.2f %.2f", x->togxpos, x->togypos);
metro = newobject_sprintf(patcher, 
    "@maxclass newobj @text \"metro 400\" @patching_position %.2f %.2f", x->metxpos, x->metypos);
```

#### connecting objects

If you'd like to script the connections between two objects, you can do so via a message to the patcher. Assuming you have the patcher, toggle, and metro objects above, you'll create an array of atoms to send the message using `object_method_typed()`.

```c
t_atom msg[4], rv;
atom_setobj(msg, toggle);
atom_setlong(msg + 1, 0);
atom_setobj(msg + 2, metro);    // destination
atom_setlong(msg + 3, 0);       // inlet number (0 is leftmost)
object_method_typed(patcher, gensym("connect"), 4, msg, &rv);
```

If you want to have a hidden connection, pass an optional fifth argument that is any negative number.

To delete an object in a patcher you call `object_free()` on the box. As of Max 5.0.6 this will properly redraw the patcher and remove any connected patch cords.

#### Obtaining and Changing Patcher and Object Attributes

lots of options to change attrs of patcher and box objects.

- Attributes whose type is object can be accessed via `object_attr_getobj()` / `object_attr_setobj()`.

- Attributes whose type is char can be `accessed with object_attr_getchar()` / `object_attr_setchar()`.

- Attributes whose type is long can be accessed with `object_attr_getlong()` / `object_attr_setlong()`.

- Attributes whose type is symbol can be accessed via `object_attr_getsym()` / `object_attr_setsym()`.

- For attributes that are arrays, such as colors and rectangles, use `object_attr_getvalueof()` / `object_attr_setvalueof()`.

To access an attribute of a non-UI object, use `jbox_get_object()` on the box to obtain the non-UI object first.

### chapter 14: Enhancements to Objects

#### Assistance

The function below has two inlets and one outlet. The io argument will be 1 for inlets, 2 for outlets. The index argument will be 0 for the leftmost inlet or outlet. You can copy a maximum of 512 characters to the output string s. You can use strncpy_zero() to copy the string, or if you want to format the assistance string based on a current value in the object, you could use `snprintf_zero()`.

```c
void myobject_assist(t_myobject *x, void *b, long io, long index, char *s)
{
    switch (io) {
        case 1:
            switch (index) {
                case 0:
                    strncpy_zero(s, "This is a description of the leftmost inlet", 512);
                    break;
                case 1:
                    strncpy_zero(s, "This is a description of the rightmost inlet", 512);
                    break;
            }
            break;
        case 2:
            strncpy_zero(s, "This is a description of the outlet", 512);
            break;
    }
}
```

#### Text editor

Objects such as coll and text display a text editor window when you double-click. Users can edit the contents of the objects and save the updated data (or not). Here's how to do the same thing in your object.

First, if you want to support double-clicking on a non-UI object, you can respond to the dblclick message.

```c
class_addmethod(c, (method)myobject_dblclick, "dblclick",
      A_CANT, 0);
void myobject_dblclick(t_myobject *x)
{
    // open editor here
}

```

You'll need to add a t_object pointer to your object's data structure to hold the editor.

```c

typedef struct _myobject
{
    t_object m_obj;
    t_object *m_editor;
} t_myobject;
```

Initialize the m_editor field to NULL in your new instance routine. Then implement the dblclick method as follows:

```c
if (!x->m_editor)
    x->m_editor = object_new(CLASS_NOBOX, gensym("jed"), (t_object *)x, 0);
else
    object_attr_setchar(x->m_editor, gensym("visible"), 1);

```

The code above does the following: If the editor does not exist, we create one by making a "jed" object and passing our object as an argument. This permits the editor to tell our object when the window is closed.

If the editor does exist, we set its visible attribute to 1, which brings the text editor window to the front.

To set the text of the edit window, we can send our jed object the settext message with a zero-terminated buffer of text. We also provide a symbol specifying how the text is encoded. For best results, the text should be encoded as UTF-8. Here is an example where we set a string to contain "Some text to edit" then pass it to the editor.

```c
char text[512];
strcpy(text,"Some text to edit");
object_method(x->m_editor, gensym("settext"), text, gensym("utf-8"));
```

The title attribute sets the window title of the text editor.

```c
object_attr_setsym(x->m_editor, gensym("title"), gensym("crazytext"));
```

When the user closes the text window, your object (or the object you passed as an argument when creating the editor) will be sent the edclose message.

```c
class_addmethod(c, (method)myobject_edclose, "edclose", A_CANT, 0);
```

The edclose method is responsible for doing something with the text. It should also zero the reference to the editor stored in the object, because it will be freed. A pointer to the text pointer is passed, along with its size. The encoding of the text is always UTF-8.

```c
void myobject_edclose(t_myobject *x, char **ht, long size)
{
    // do something with the text
    x->m_editor = NULL;
}
```

If your object will be showing the contents of a text file, you are still responsible for setting the initial text, but you can assign a file so that the editor will save the text data when the user chooses Save from the File menu. To assign a file, use the filename message, assuming you have a filename and path ID.

```c
object_method(x->m_editor, gensym("filename"), x->m_myfilename, x->m_mypath);
```

The filename message will set the title of the text editor window, but you can use the title attribute to override the simple filename. For example, you might want the name of your object to precede the filename:

```c
char titlename[512];
sprintf(titlename, "myobject: %s", x->m_myfilename);
object_attr_setsym(x->m_editor, gensym("title"), gensym(titlename));
```

Each time the user chooses Save, your object will receive an edsave message. If you return zero from your edsave method, the editor will proceed with saving the text in a file. If you return non-zero, the editor assumes you have taken care of saving the text. The general idea is that when the user wants to save the text, it is either updated inside your object, updated in a file, or both. As an example, the js object uses its edsave message to trigger a recompile of the Javascript code. But it also returns 0 from its edsave method so that the text editor will update the script file. Except for the return value, the prototype of the edsave method is identical to the edclose method.

```c
class_addmethod(c, (method)myobject_edsave, "edsave",
      A_CANT, 0);
long myobject_edsave(t_myobject *x, char **ht, long size)
{
    // do something with the text
    return 0;       // tell editor it can save the text
}
```

## Memory Management

see: <https://cycling74.com/forums/multislider-like-ui>

example

```c
t_max_err MY_getvalueof(t_MY *x, long *ac, t_atom **av)
{
    if (ac && av) {
        char alloc;
        if (atom_alloc_array(x->listlen, ac, av, &alloc)) {
            return MAX_ERR_OUT_OF_MEM;
        }
        atom_setfloat_array(*ac, *av, x->listlen, x->myval);
    }
    return MAX_ERR_NONE;
}
```

also

```c
char *ptr;
char **hand;
ptr = sysmem_newptr(2000);
post("I have a pointer %lx and it is %ld bytes in size",ptr, sysmem_ptrsize(ptr));
ptr = sysmem_resizeptrclear(ptr, 3000);
post("Now I have a pointer %lx and it is %ld bytes in size",ptr,
      sysmem_ptrsize(ptr));
sysmem_freeptr(ptr);
hand = sysmem_newhandle(2000);
post("I have a handle %lx and it is %ld bytes in size",hand,
      sysmem_handlesize(hand));
sysmem_resizehandle(hand, 3000);
post("Now the handle %lx is %ld bytes in size",hand, sysmem_ptrsize(hand));
sysmem_freehandle(hand);
```

## Getting the Type of Methods Programmatically

methods to get method type

see: <https://github.com/Cycling74/min-api/blob/55c65a02a7d4133ac261908f5d47e1be2b7ef1fb/include/c74_min_patcher.h#L101>

```cpp
<template<typename T1, typename T2>
atom operator()(symbol method_name, T1 arg1, T2 arg2) {
    auto m { find_method(method_name) };

    if (m.type == max::A_GIMME) {
        atoms   as { arg1, arg2 };
        return max::object_method_typed(m.ob, method_name, as.size(), &as[0], nullptr);
    }
    else if (m.type == max::A_GIMMEBACK) {
        atoms       as { arg1, arg2 };
        max::t_atom rv {};

        max::object_method_typed(m.ob, method_name, as.size(), &as[0], &rv); 
        return rv;
    }
    else {
        if (typeid(T1) != typeid(atom))
            return m.fn(m.ob, arg1, arg2);
        else {
          // atoms must be converted to native types and then reinterpreted as void*
          // doubles cannot be converted -- supporting those will
          // need to be handled separately 
          return m.fn(m.ob, atom_to_generic(arg1), atom_to_generic(arg2));
        }
    }
}
```

### object_mess

- object **must** cast to `(t_object*)` or fail

- the `char` type of `m_type` is confusing, m_type[0] as a `int` is what is needed!

```c
t_messlist* mess = object_mess((t_object*)obj, msg_sym);
if (mess) {
    object_post(NULL, "method name: %s, type: %d", mess->m_sym->s_name,
                mess->m_type[0]);
}
```

### object_getmethod_object

```c
t_method_object* mobj = object_getmethod_object(obj, msg_sym);
t_messlist m_entry = mobj->messlist_entry;
post("MESSLIST_ENTRY method_name %s type %d", m_entry.m_sym->s_name,
     m_entry.m_type[0]);
```

## Typed vs Untyped Methods

This is from the Max API docs:

Max objects, such as the one you write, are C data structures in which methods are dynamically bound to functions. Your object's methods are called by Max, but your object can also call methods itself. When you call a method, it is essential to know whether the method you are calling is typed or not.

Calling a typed method requires passing arguments as an array of atoms. Calling an untyped method requires that you know the exact arguments of the C function implementing the method. In both cases, you supply a symbol that names the method.

In the typed method case, Max will take the array of atoms and pass the arguments to the object according to the method's argument type specifier list. For example, if the method is declared to have an argument type specifier list of A_LONG, 0, the first atom in the array you pass will be converted to an int and passed to the function on the stack. If there are no arguments supplied, invoking a typed method that has A_LONG, 0 as an argument type specifier will fail. To make typed method calls, use `object_method_typed()` or `typedmess()`.

In the untyped method case, Max merely does a lookup of the symbol in the object, and, if a matching function is found, calls the function with the arguments you pass.
Certain methods you write for your object, such as the assist method for describing your object and the DSP method in audio objects, are declared as untyped using the A_CANT argument type specifier. This means that Max will not typecheck the arguments you pass to these methods, but, most importantly, a user cannot hook up a message box to your object and send it a message to invoke an untyped method. (Try this for yourself – send the assist message to a standard Max object.)

When you use an outlet, you're effectively making a typed method call on any objects connected to the outlet.

## Sending arbitrary messages to an object

In <https://cycling74.com/forums/error-handling-with-object_method_typed>, there is a need to figure the type of the method which is being called in sending.

It looks like the `t_messlist` struct in `t_object` is key!

### Forum Discussions

see: <https://cycling74.com/forums/error-handling-with-object_method_typed>

In the Min-Devkit there is an example object called min.remote whose source code is @ <https://github.com/Cycling74/min-devkit/blob/master/source/projects/min.remote/min.remote.cpp>
On line 35 a method is called on the "box".  What happens inside of this to get to the correct incantation of object_method() and friends is on line 101 of the file @ <https://github.com/Cycling74/min-api/blob/55c65a02a7d4133ac261908f5d47e1be2b7ef1fb/include/c74_min_patcher.h#L101>

```cpp
template<typename T1, typename T2>
        atom operator()(symbol method_name, T1 arg1, T2 arg2) {
            auto m { find_method(method_name) };

            if (m.type == max::A_GIMME) {
                atoms   as { arg1, arg2 };
                return max::object_method_typed(m.ob, method_name, as.size(), &as[0], nullptr);
            }
            else if (m.type == max::A_GIMMEBACK) {
                atoms       as { arg1, arg2 };
                max::t_atom rv {};

                max::object_method_typed(m.ob, method_name, as.size(), &as[0], &rv);
                return rv;
            }
            else {
                if (typeid(T1) != typeid(atom))
                    return m.fn(m.ob, arg1, arg2);
                else {
                    // atoms must be converted to native types and then reinterpreted as void*
                    // doubles cannot be converted -- supporting those will need to be handled separately
                    return m.fn(m.ob, atom_to_generic(arg1), atom_to_generic(arg2));
                }
            }
        }
```

see: <https://cycling74.com/forums/sending-arbitrary-messages-to-other-objects-from-c>

Sending to a coll:

Assuming you already have a valid pointer to a Max object the API  function you use to send a message to a receiving object is:

`object_method()` for methods where Max cannot type check the arguments (`A_CANT`)

or

`object_method_typed()` for methods that take a certain number of arguments of a certain type and therefore have a typed function signature (`A_GIMME`)

If you want to send messages to Max object instantiated in a patch, you probably will want to use `object_method_typed()`.

Be aware that in `ext_obex_util.h` there is a number of convenience functions that allow you to specifically send integer, floats, symbols and more...

For example, if you wanted to send the clear message to a [coll] object, this is the code you would write:

`object_method_typed(collObjPtr, gensym("clear"), 0, NULL, NULL);`

or shorter version: (untyped)

`object_method(collObjPtr, gensym("clear"));`

In this example since the message "clear" has no arguments the typed/untyped distinction doesn't really matter and you could use them interchangeably.

### ext_mess.h

```c

/** A list of symbols and their corresponding methods,
  complete with typechecking information. 
  @ingroup obj
*/
typedef struct messlist
{
  struct symbol *m_sym;   ///< Name of the message
  method m_fun;       ///< Method associated with the message
  char m_type[MSG_MAXARG + 1];  ///< Argument type information
} t_messlist;
C74_DEPRECATED( typedef struct messlist Messlist );

//...

/** The structure for the head of any object which wants to have inlets or outlets,
  or support attributes.
  @ingroup obj
*/
typedef struct object
{
  struct messlist *o_messlist;  ///<  list of messages and methods. The -1 entry of the message list of an object contains a pointer to its #t_class entry.
                  // (also used as freelist link)
#ifdef CAREFUL
  t_ptr_int o_magic;          ///< magic number
#endif
  struct inlet *o_inlet;      ///<  list of inlets
  struct outlet *o_outlet;    ///<  list of outlets
} t_object;
C74_DEPRECATED( typedef struct object Object );

```

Look for functions which return `t_messlist`

### ext_obex.h

Undocumented:

```c
t_messlist *class_mess(t_class *x, t_symbol *methodname);
t_messlist *object_mess(t_object *x, t_symbol *methodname); // <- promising!
t_messlist *class_typedwrapper_get(t_class *x, t_symbol *s);
t_messlist *object_typedwrapper_get(t_object *x, t_symbol *s);
```

There is a `t_method_object` as well:

```c
typedef struct _method_object
{
  t_object  ob;
  t_messlist  messlist_entry;
} t_method_object;
```

Undocumented:

```c
t_method_object *method_object_new(method m, C74_CONST char *name, ...);
t_method_object *method_object_new_messlist(t_messlist *m);
void method_object_free(t_method_object *x);
t_symbol *method_object_getname(t_method_object *x);
void method_object_setname(t_method_object *x, t_symbol *s);
method method_object_getmethod(t_method_object *x);
void method_object_setmethod(t_method_object *x, method m);
t_messlist *method_object_getmesslist(t_method_object *x);
void method_object_setmesslist(t_method_object *x, t_messlist *m);

t_method_object *class_getmethod_object(t_class *x, t_symbol *methodname);

// these methods are private -- instance methods are not actually fully implemented at this time
t_method_object *object_getmethod_object(t_object *x, t_symbol *methodname);
```

For Untyped Methods (A_CANT)

```c

/**
  Sends an untyped message to an object. 
  There are some caveats to its use, however, particularly for 64-bit architectures.
  object_method_direct() should be used in cases where floating-point or other non-integer types are being passed on the stack or in return values.

  @ingroup obj

  @param  x   The object that will receive the message 
  @param  s   The message selector
  @param  ...   Any arguments to the message

  @return     If the receiver object can respond to the message, object_method() returns the result. Otherwise, the function will return 0. 

  @remark     Example: To send the message <tt>bang</tt> to the object <tt>bang_me</tt>:
  void *bang_result;
  bang_result = object_method(bang_me, gensym("bang"));
  @endcode
*/

void *object_method(void *x, t_symbol *s, ...);

/**
  do a strongly typed direct call to a method of an object

  @ingroup obj

  
  @param  rt    The type of the return value (double, void*, void...)
  @param  sig   the actual signature of the function in brackets ! 
          something like (t_object *, double, long)   
  @param  x   The object where the method we want to call will be looked for,
          it will also always be the first argument to the function call
  @param  s   The message selector
  @param  ...   Any arguments to the call, the first one will always be the object (x)

  @return     will return anything that the called function returns, typed by (rt)
 
  @remark     Example: To call the function identified by <tt>getcolorat</tt> on the object <tt>pwindow</tt>
          which is declared like:
          t_jrgba pwindow_getcolorat(t_object *window, double x, double y)
  double x = 44.73;
  double y = 79.21;
  t_object *pwindow;
  t_jrgba result = object_method_direct(t_jrgba, (t_object *, double, double), pwindow, gensym("getcolorat"), x, y);
  @endcode
*/
    
#define object_method_direct(rt, sig, x, s, ...) ((rt (*)sig)object_method_direct_getmethod((t_object *)x, s))(object_method_direct_getobject((t_object *)x, s), __VA_ARGS__)

method object_method_direct_getmethod(t_object *x, t_symbol *sym);
void *object_method_direct_getobject(t_object *x, t_symbol *sym);
```

For Typed Methods (A_GIMME)

```c
/**
  Sends a type-checked message to an object.

  @ingroup obj

  @param  x   The object that will receive the message 
  @param  s   The message selector
  @param  ac    Count of message arguments in <tt>av</tt>
  @param  av    Array of t_atoms; the message arguments
  @param  rv    Return value of function, if available

  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.

  @remark     If the receiver object can respond to the message, object_method_typed() returns the result in <tt>rv</tt>. Otherwise, <tt>rv</tt> will contain an #A_NOTHING atom.
*/
t_max_err object_method_typed(void *x, t_symbol *s, long ac, t_atom *av, t_atom *rv);
```

### ext_obex_util.h

```c
/**
  Convenience wrapper for object_method_typed() that uses atom_setparse() to define the arguments.

  @ingroup  obj
  @param    x     The object to which the message will be sent.
  @param    s     The name of the method to call on the object.
  @param    parsestr  A C-string to parse into an array of atoms to pass to the method.
  @param    rv      The address of an atom to hold a return value.
  @return   A Max error code.
  
  @see    object_method_typed()
  @see    atom_setparse()
*/
t_max_err object_method_parse(t_object *x, t_symbol *s, C74_CONST char *parsestr, t_atom *rv);
```

## Object Reference

It looks like `obex` is a type `hashtab` (Hash Table), which can be used for storing object references?

## Find named object

see: <https://cycling74.com/forums/find-named-object-and-send-it-a-message>

  I'm looking at some of the patcher scripting stuff in the api.  iterator.c is a good guide, but I do want to check if there's  a simple method similar to "getnamed" in javascript, such that I don't have to iterate through all the boxes in a patcher.
  Something along the lines of

```c
  t_object *desiredobject = jpatcher_get_namedobject("scriptedname");
```

  and you could then just pass desiredobject into the various jbox goodies.

and the answer

```c
t_max_err err;
t_object *patcher = NULL;
t_object *yourobject = NULL;

// get the patcher
err = object_obex_lookup(yourobjectpointer, gensym("#P"), &patcher);

// get the object that you're looking for.
yourobject = (t_object *)object_method(patcher, gensym("getnamedbox"), gensym("theobjectname"));
```

----

see: <https://cycling74.com/forums/error-handling-with-object_method_typed>

Avoiding crashes when sending:

  For messages which are internally defined as A_GIMME the correct call to use is object_method_typed(). But for other messages, say one with A_FLOAT as the argument, you will likely want to use object_method().

----

see: <https://cycling74.com/forums/messnamed-equivalent-send-function-in-c-send-to-named-object>

Question:

  "want to send values to a named object, as there is in javascript with 'messnamed'... send values to receive objects."

Answer:

  all send's and receive's with the same name reference a single nobox object called "through", which you can simply retrieving by looking at the s_thing field of the name symbol — I mean, if you need to retrieve the through object associated to the "foo" symbol, just look for gensym("foo")->s_thing.
  Once you have the object, just send it a message with object_method().

```c
t_max_err object_send_method_typed(void *x, t_symbol *name, t_symbol *s, long ac, t_atom *av, t_atom *rv)
{
   t_object *thing = name->s_thing;

   if (!thing) {
       return MAX_ERR_INVALID_PTR;
   }
   if (NOGOOD(thing)) {
       return MAX_ERR_INVALID_PTR;
   }
   if (!object_classname_compare(thing, gensym("through"))) {
       return MAX_ERR_GENERIC;
   }
   return object_method_typed(thing, s, ac, av, rv);
}
```

## Storing Refs on a Hashtable

see: <https://cycling74.com/forums/help!-crashing-when-scripting-patcher-and-storing-refs-in-a-hashtable>

... solution for future readers: I needed to use the OBJ_FLAG_REF flag to the hashtab so that it wouldn't try to free pointers to objects.

## Coding GIMMEBACK

see: <https://cycling74.com/forums/multiple-atoms-return-by-a_gimmeback>
     <https://github.com/Cycling74/min-api/blob/main/include/c74_min_patcher.h>

```c
void max_jit_obex_gimmeback_dumpout(void *x, t_symbol *s, long ac, t_atom *av)
{
    t_atom rv;
    t_atom *rav = NULL;
    long rac = 0;
    object_method_typed(max_jit_obex_jitob_get(x),s,ac,av,&rv);
    if (rv.a_type == A_NOTHING) return;
    if (rv.a_type == A_OBJ) { 
        object_getvalueof(rv.a_w.w_obj, &rac, &rav);
    } else {
        rac = 1;
        rav = &rv;
    }
    if (s&&s->s_name[0]=='g'&& s->s_name[1]=='e'&& s->s_name[2]=='t')
        s = gensym(s->s_name+3);
    max_jit_obex_dumpout(x,s,rac,rav);
    if (rv.a_type==A_OBJ) { 
        if (rac&&rav)
            freebytes(rav,rac*sizeof(t_atom));    
        if(rv.a_w.w_obj)
            freeobject(rv.a_w.w_obj); 
  }
}
```

## Path operations

see: <https://cycling74.com/forums/locatefolder>

## Compiling on Ubuntu 20.04

see: <https://stackoverflow.com/questions/27672572/embedding-python-in-c-linking-fails-with-undefined-reference-to-py-initialize>

## Writing a text file

see: <https://cycling74.com/forums/problem-with-sysfile_writetextfile>

```c
 void buffTest_writefile(t_buffTest *x, char *filename, short path)
{
    char *buf  = "write me to a file";
    t_handle h = sysmem_newhandle(0);
    sysmem_ptrandhand(buf, h, strlen(buf));
    long err;
    t_filehandle fh;
    err = path_createsysfile(filename, path, 'TEXT', &fh);
    if (err)
        return;
    err = sysfile_writetextfile(fh, h, TEXT_LB_NATIVE);
    sysfile_close(fh);
    sysmem_freehandle(h);
}
```

## Getting Atoms from Argument

in ext_obex.h:

```c
/**
  Retrieves type from a #t_atom. 

  @ingroup atom
  @param  a   Pointer to a #t_atom whose type is of interest
  @return     This function returns the type of the specified t_atom as defined in #e_max_atomtypes
*/
long atom_gettype(const t_atom *a);

//the following are useful for setting the values _only_ if there is an arg
//rather than setting it to 0 or _sym_nothing

/**
  Retrieves the integer value of a particular t_atom from an atom list, if the atom exists.

  @ingroup atom

  @param  c   Pointer to a long variable to receive the atom's data if the function is successful.
  @param  idx   Offset into the atom list of the atom of interest, starting from 0. 
          For instance, if you want data from the 3rd atom in the atom list, <tt>idx</tt> should be set to 2.
  @param  ac    Count of av.
  @param  av    Pointer to the first t_atom of an atom list.

  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.

  @remark     The atom_arg_getlong() function only changes the value of <tt>c</tt> if the function is successful. 
          For instance, the following code snippet illustrates a simple, but typical use:
  void myobject_mymessage(t_myobject *x, t_symbol *s, long ac, t_atom *av)
  {
    t_atom_long var = -1;

    // here, we are expecting a value of 0 or greater
    atom_arg_getlong(&var, 0, ac, av);
    if (val == -1) // i.e. unchanged
      post("it is likely that the user did not provide a valid argument");
    else {
      ...
    }
  }
  @endcode
*/
t_max_err atom_arg_getlong(t_atom_long *c, long idx, long ac, const t_atom *av);


/**
  Retrieves the floating point value of a particular t_atom from an atom list, if the atom exists.

  @ingroup atom

  @param  c   Pointer to a float variable to receive the atom's data if the function is successful. Otherwise, the value is left unchanged.
  @param  idx   Offset into the atom list of the atom of interest, starting from 0. 
          For instance, if you want data from the 3rd atom in the atom list, <tt>idx</tt> should be set to 2.
  @param  ac    Count of av.
  @param  av    Pointer to the first t_atom of an atom list.

  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.
*/
long atom_arg_getfloat(float *c, long idx, long ac, const t_atom *av);


/**
  Retrieves the floating point value, as a double, of a particular t_atom from an atom list, if the atom exists.

  @ingroup atom

  @param  c   Pointer to a double variable to receive the atom's data if the function is successful. Otherwise the value is left unchanged.
  @param  idx   Offset into the atom list of the atom of interest, starting from 0. 
          For instance, if you want data from the 3rd atom in the atom list, <tt>idx</tt> should be set to 2.
  @param  ac    Count of av.
  @param  av    Pointer to the first t_atom of an atom list.

  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.
*/
long atom_arg_getdouble(double *c, long idx, long ac, const t_atom *av);


/**
  Retrieves the t_symbol * value of a particular t_atom from an atom list, if the atom exists.

  @ingroup atom

  @param  c   Pointer to a t_symbol * variable to receive the atom's data if the function is successful. Otherwise, the value is left unchanged.
  @param  idx   Offset into the atom list of the atom of interest, starting from 0. 
          For instance, if you want data from the 3rd atom in the atom list, <tt>idx</tt> should be set to 2.
  @param  ac    Count of av.
  @param  av    Pointer to the first t_atom of an atom list.

  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.

  @remark     The atom_arg_getsym() function only changes the value of <tt>c</tt> if the function is successful. 
          For instance, the following code snippet illustrates a simple, but typical use:
  void myobject_open(t_myobject *x, t_symbol *s, long ac, t_atom *av)
  {
    t_symbol *filename = _sym_nothing;

    // here, we are expecting a file name.
    // if we don't get it, open a dialog box 
    atom_arg_getsym(&filename, 0, ac, av);
    if (filename == _sym_nothing) { // i.e. unchanged
      // open the file dialog box,
      // get a value for filename
    }
    // do something with the filename
  }
  @endcode
*/
long atom_arg_getsym(t_symbol **c, long idx, long ac, const t_atom *av);
```

## Object Creation & Freeing

in ext_obex.h

```c
/**
  Allocates the memory for an instance of an object class and initialize its object header <em>internal to Max</em>. 
  It is used similarly to the traditional function newinstance(), but its use is required with obex-class objects. 
  The object_new_typed() function differs from object_new() by its use of an atom list for object arguments—in this way, 
  it more resembles the effect of typing something into an object box from the Max interface.

  @ingroup obj

  @param  name_space  The desired object's name space. Typically, either the 
            constant #CLASS_BOX, for obex classes which can 
            instantiate inside of a Max patcher (e.g. boxes, UI objects, 
            etc.), or the constant #CLASS_NOBOX, for classes 
            which will only be used internally. Developers can define 
            their own name spaces as well, but this functionality is 
            currently undocumented.
  @param  classname The name of the class of the object to be created
  @param  ac      Count of arguments in <tt>av</tt>
  @param  av      Array of t_atoms; arguments to the class's instance creation function.

  @return       This function returns a new instance of the object class if successful, or NULL if unsuccessful.
*/
void *object_new_typed(t_symbol *name_space, t_symbol *classname, long ac, t_atom *av);


/**
  Call the free function and release the memory for an instance of an internal object class previously instantiated using object_new(), object_new_typed() or other new-style object constructor functions (e.g. hashtab_new()). 
  It is, at the time of this writing, a wrapper for the traditional function freeobject(), but its use is suggested with obex-class objects.

  @ingroup obj
  @param  x   The pointer to the object to be freed. 
  @return     This function returns the error code #MAX_ERR_NONE if successful, 
          or one of the other error codes defined in #e_max_errorcodes if unsuccessful.
*/
t_max_err object_free(void *x);
```

## Checking whether an object is an instance of a class

in ext_obex.h

```c
/**
  Determines if a particular object is an instance of a given class.

  @ingroup obj

  @param  x   The object to test
  @param  name  The name of the class to test this object against
  @return     This function returns 1 if the object is an instance of the named class. Otherwise, 0 is returned.
  @remark     For instance, to determine whether an unknown object pointer is a pointer to a print object, one would call:

  long isprint = object_classname_compare(x, gensym("print"));
  @endcode
*/
long object_classname_compare(void *x, t_symbol *name);
```

## Outlets

- outlet creation order is important in `outlet_new(x, NULL)`?

### Dynamic Outlets

see: <https://cycling74.com/forums/dynamic-inlets-outlets>

```c
// start the transaction with the box
t_object *b = NULL;
object_obex_lookup(x, _sym_pound_B, (t_object **)&b);
object_method(b, gensym("dynlet_begin"));

// update outlets with one or both of these calls
//outlet_delete(outlet_nth((t_object*)x, i));
//outlet_append((t_object*)x, NULL, gensym("signal"));

// end the transaction with the box
object_method(b, gensym("dynlet_end"));
```
