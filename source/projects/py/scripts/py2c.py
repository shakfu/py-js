#!/usr/bin/env python3

"""py2c -- Convert a python source file into a c-header"""

import io
import re
import tokenize

inputs = {
    'py_prelude.py' : 'PY_PRELUDE_MODULE',
    # 'fn.py'     : 'PY_FUNCTIONAL_MODULE',
}

OUTPUT='py_prelude.h'


def remove_comments_and_docstrings(source):
    """Returns 'source' minus comments and docstrings.

    ref: https://stackoverflow.com/questions/1769332/script-to-remove-python-comments-docstrings
    """
    io_obj = io.StringIO(source)
    out = ""
    prev_toktype = tokenize.INDENT
    last_lineno = -1
    last_col = 0
    for tok in tokenize.generate_tokens(io_obj.readline):
        token_type = tok[0]
        token_string = tok[1]
        start_line, start_col = tok[2]
        end_line, end_col = tok[3]
        ltext = tok[4]
        # The following two conditionals preserve indentation.
        # This is necessary because we're not using tokenize.untokenize()
        # (because it spits out code with copious amounts of oddly-placed
        # whitespace).
        if start_line > last_lineno:
            last_col = 0
        if start_col > last_col:
            out += (" " * (start_col - last_col))
        # Remove comments:
        if token_type == tokenize.COMMENT:
            pass
        # This series of conditionals removes docstrings:
        elif token_type == tokenize.STRING:
            if prev_toktype != tokenize.INDENT:
        # This is likely a docstring; double-check we're not inside an operator:
                if prev_toktype != tokenize.NEWLINE:
                    # Note regarding NEWLINE vs NL: The tokenize module
                    # differentiates between newlines that start a new statement
                    # and newlines inside of operators such as parens, brackes,
                    # and curly braces.  Newlines inside of operators are
                    # NEWLINE and newlines that start new code are NL.
                    # Catch whole-module docstrings:
                    if start_col > 0:
                        # Unlabelled indentation means we're inside an operator
                        out += token_string
                    # Note regarding the INDENT token: The tokenize module does
                    # not label indentation inside of an operator (parens,
                    # brackets, and curly braces) as actual indentation.
                    # For example:
                    # def foo():
                    #     "The spaces before this docstring are tokenize.INDENT"
                    #     test = [
                    #         "The spaces before this string do not get a token"
                    #     ]
        else:
            out += token_string
        prev_toktype = token_type
        last_col = end_col
        last_lineno = end_line
    return out


def to_cstr(py_code, varname):
    py_code = py_code.replace('"', '\\"')
    lines = py_code.split('\n')
    lines = [f'"{line}\\n"' for line in lines]
    return f'\nstatic const char* {varname} =\n'+'\n'.join(lines)+';'

def remove_multiple_empty_lines(contents):
    # ref: https://stackoverflow.com/questions/28901452/reduce-multiple-blank-lines-to-single-pythonically
    return re.sub(r'\n\s*\n', '\n\n', contents)

def main(strip_docstrings=True, strip_multiple_lines=True):
    with open(OUTPUT, 'w') as outfile:
        print("// py_prelude.h: pure python functions for the `py` external", file=outfile)
        print("// generated by `py/scripts/py2c.py`", file=outfile)
        for filename in inputs:
            with open(filename) as f:
                lines = f.readlines()
                _lines = []
                include = True
                for line in lines:
                    if line.startswith("if __name__ == "):
                        include = False
                    if include:
                        _lines.append(line)
                contents = "".join(_lines)

                if strip_docstrings:
                    contents = remove_comments_and_docstrings(contents)
                if strip_multiple_lines:
                    contents = remove_multiple_empty_lines(contents)
                print(to_cstr(contents, inputs[filename]), 
                    file=outfile)


if __name__ == '__main__':
    import argparse
    main()


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
        prog='py2c',
        description='Convert a python source file into a c-header',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument('-d', '--rm-docs', action='store_false', help="Remove comments and docstrings")
    parser.add_argument('-e', '--rm-empty-lines', action='store_false', help="Remove multiple empty lines")

    args = parser.parse_args()
    main(
        strip_docstrings=args.rm_docs,
        strip_multiple_lines=args.rm_empty_lines
    )
