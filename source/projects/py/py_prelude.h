// py_prelude.h: pure python functions for the `py` external
// generated by `py/scripts/py2c.py`

static const char* PY_PRELUDE_MODULE =
"import ast\n"
"import os\n"
"import subprocess\n"
"import shlex\n"
"import collections.abc\n"
"import functools\n"
"from keyword import iskeyword as is_keyword\n"
"from inspect import signature as __signature\n"
"from typing import Any, Optional, Callable\n"
"\n"
"EDITOR = \"Sublime Text\"\n"
"\n"
"def is_sequence(obj) -> bool:\n"
"\n"
"    if isinstance(obj, str):\n"
"        return False\n"
"    return isinstance(obj, collections.abc.Sequence)\n"
"\n"
"def is_iterable(obj) -> bool:\n"
"\n"
"    if hasattr(obj, \"__iter__\"):\n"
"        return True\n"
"    if isinstance(obj, collections.abc.Iterable):\n"
"        return True\n"
"    try:\n"
"        iter(obj)\n"
"        return True\n"
"    except TypeError:\n"
"        pass\n"
"    return False\n"
"\n"
"def to_val(elem: Any, gdict: Optional[dict] = None) -> Any:\n"
"    if not gdict:\n"
"        gdict = globals()\n"
"    if isinstance(elem, (int, float)):\n"
"        return elem\n"
"    elif isinstance(elem, dict):\n"
"        return elem\n"
"    elif isinstance(elem, tuple):\n"
"        return elem\n"
"    elif isinstance(elem, set):\n"
"        return elem\n"
"    elif isinstance(elem, str):\n"
"        val = None\n"
"        try:\n"
"            val = ast.literal_eval(elem)\n"
"        except ValueError:\n"
"            if elem in gdict:\n"
"                val = eval(elem, globals=gdict)\n"
"        except SyntaxError:\n"
"            print(elem)\n"
"            return\n"
"        return val\n"
"    elif callable(elem):\n"
"        return elem\n"
"    else:\n"
"        return to_val(repr(type(elem)))\n"
"\n"
"def to_fn(s: str, gdict: Optional[dict] = None) -> Callable:\n"
"\n"
"    if not gdict:\n"
"        gdict = globals()\n"
"    assert s in gdict, \"function not defined\"\n"
"    fn = eval(s, globals=gdict)\n"
"    assert callable(fn), \"not a callable\"\n"
"    return fn\n"
"\n"
"def compose(f: Callable, g: Callable) -> Callable:\n"
"\n"
"    return lambda x: f(g(x))\n"
"\n"
"def analyze(s: str, gdict: Optional[dict] = None) -> tuple[list[Callable], list[Any], list[tuple[Any, Any]]]:\n"
"\n"
"    if not gdict:\n"
"        gdict = globals()\n"
"    fs = []\n"
"    args = []\n"
"    kwargs = []\n"
"    str_args = s.split()\n"
"    for str_arg in str_args:\n"
"        if \"=\" in str_arg:\n"
"            k, v = str_arg.split(\"=\")\n"
"            kwargs.append((eval(repr(k), globals=gdict), eval(v, globals=gdict)))\n"
"        else:\n"
"            try:\n"
"                elem = eval(str_arg, globals=gdict)\n"
"            except SyntaxError:\n"
"                elem = eval(repr(str_arg), globals=gdict)\n"
"            if callable(elem):\n"
"                fs.append(elem)\n"
"            else:\n"
"                args.append(elem)\n"
"    return fs, args, kwargs\n"
"\n"
"def list_to_dict(xs: list, eval_values=False) -> dict:\n"
"\n"
"    print(\"xs\", xs)\n"
"    result = {}\n"
"    if not xs:\n"
"        return result\n"
"\n"
"    seps = [i for i, x in enumerate(xs) if x == \":\"]\n"
"\n"
"    if not seps:\n"
"        return result\n"
"\n"
"    prev_idx = 0\n"
"    for i in range(len(seps)):\n"
"        sep_idx = seps[i]\n"
"        key = xs[prev_idx]\n"
"\n"
"        if not isinstance(key, str) or is_keyword(key) or not key.isidentifier():\n"
"            raise ValueError(f\"key {key} is not a valid python identifier\")\n"
"\n"
"        if i < len(seps) - 1:\n"
"            end_idx = seps[i + 1] - 1\n"
"        else:\n"
"            end_idx = len(xs)\n"
"\n"
"        values = xs[sep_idx + 1 : end_idx]\n"
"        if eval_values:\n"
"            values = [to_val(val) for val in values]\n"
"\n"
"        if len(values) == 1:\n"
"            values = values[0]\n"
"\n"
"        result[key] = values\n"
"        prev_idx = end_idx\n"
"\n"
"    return result\n"
"\n"
"def shell(cmd: str, err_func: Optional[Callable] = None) -> Optional[Any]:\n"
"\n"
"    result = None\n"
"    try:\n"
"        elems = shlex.split(cmd)\n"
"        elems[-1] = os.path.expanduser(elems[-1])  \n"
"        result = subprocess.check_output(elems, encoding=\"utf8\").strip()\n"
"    except subprocess.CalledProcessError as e:\n"
"        if err_func:\n"
"            err_func(e.stderr)\n"
"    except FileNotFoundError as e:\n"
"        if err_func:\n"
"            err_func(e.strerror)\n"
"    if result:\n"
"        return result\n"
"\n"
"def out_dict(py_dict: dict) -> list:\n"
"\n"
"    res = []\n"
"    for k, v in py_dict.items():\n"
"        res.append(k)\n"
"        res.append(\":\")\n"
"        if type(v) in [list, set, tuple]:\n"
"            for i in v:\n"
"                res.append(i)\n"
"        else:\n"
"            res.append(v)\n"
"    return res\n"
"\n"
"def pipe(s: str, gdict: Optional[dict] = None) -> Any:\n"
"\n"
"    fs, args, kwargs = analyze(s, gdict)\n"
"    if args and fs:\n"
"        if len(args) == 1:\n"
"            arg = args[:].pop()\n"
"            for f in fs:\n"
"                arg = f(arg)\n"
"            return arg\n"
"        else:\n"
"            for f in fs:\n"
"                try:\n"
"                    args = list(map(f, args))\n"
"                except TypeError:\n"
"                    args = f(args)\n"
"            if args:\n"
"                return args\n"
"\n"
"def call(s: str) -> Any:\n"
"\n"
"    fs, args, kwargs = analyze(s)\n"
"    if len(fs) == 1:\n"
"        f = fs[0]\n"
"        try:\n"
"            return f(*args, **dict(kwargs))\n"
"        except TypeError:\n"
"            return f(args, **dict(kwargs))\n"
"\n"
"        return f(args[0])\n"
"\n"
"def fold(s: str, gdict: Optional[dict] = None) -> Any:\n"
"\n"
"    fs, args, kwargs = analyze(s, gdict)\n"
"    if len(fs) == 1:\n"
"        f = fs[0]\n"
"        accum, seq = args[0], args[1:]\n"
"        if len(seq) == 1:\n"
"            seq = seq[0]\n"
"        return functools.reduce(f, seq, accum)\n"
"    else:\n"
"        res = []\n"
"        for f in fs:\n"
"            accum, seq = args[0], args[1:]\n"
"            if len(seq) == 1:\n"
"                seq = seq[0]\n"
"            res.append(functools.reduce(f, seq, accum))\n"
"        return res\n"
"\n"
"def to_string(func, *args, **kwds) -> str:\n"
"\n"
"    res = [func]\n"
"    res.extend(args)\n"
"    res.extend(out_dict(kwds))\n"
"    return \" \".join(str(i) for i in res)\n"
"\n"
"def from_list(xs: list[str], gdict: Optional[dict] = None) -> tuple[Callable, tuple[Any, ...], dict[str, Any]]:\n"
"\n"
"    args = []\n"
"    kwds = []\n"
"    f = to_fn(xs[0], gdict)\n"
"    xs = xs[1:]\n"
"    if \":\" in xs:\n"
"        z = xs.index(\":\")\n"
"        kwds = xs[z - 1 :]\n"
"        args = [to_val(arg, gdict) for arg in xs[: z - 1]]\n"
"    else:\n"
"        kwds = []\n"
"        args = xs\n"
"    return f, tuple(args), list_to_dict(kwds, eval_values=True)\n"
"\n"
"def from_string(s: str, gdict: Optional[dict] = None) -> tuple[Callable, tuple[Any, ...], dict[str, Any]]:\n"
"\n"
"    xs = s.split()\n"
"    return from_list(xs, gdict)\n"
"\n"
"def apply(s: str, gdict: Optional[dict] = None) -> Any:\n"
"\n"
"    if not gdict:\n"
"        gdict = globals()\n"
"    f, args, kwds = from_string(s, gdict)\n"
"    return f(*args, **kwds)\n"
"\n"
"def edit(path: str) -> None:\n"
"\n"
"    editor = os.getenv(\"EDITOR\", EDITOR)\n"
"    path = os.path.expanduser(path)\n"
"    shell(f\"open -a '{editor}' '{path}'\")\n"
"\n"
"def product(*args) -> int | float:\n"
"\n"
"    result = 1\n"
"    for arg in args:\n"
"        result *= arg\n"
"    return result\n"
"\n"
"def sig(func) -> str:\n"
"\n"
"    name = func.__qualname__\n"
"    signature = str(__signature(func))\n"
"    return f\"<function {name}{signature}>\"\n"
"\n";
