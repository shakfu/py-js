// py_prelude.h: pure python functions for the `py` external
// generated by `py/scripts/py2c.py`

static const char* PY_PRELUDE_MODULE =
"\n"
"import os\n"
"import subprocess\n"
"import shlex\n"
"import collections.abc\n"
"import functools\n"
"\n"
"EDITOR = \"Sublime Text\"\n"
"\n"
"def is_sequence(obj):\n"
"    if isinstance(obj, str):\n"
"        return False\n"
"    return isinstance(obj, collections.abc.Sequence)\n"
"\n"
"def __compose(f, g):\n"
"    return lambda x: f(g(x))\n"
"\n"
"def __analyze(s: str):\n"
"    fs = []\n"
"    args = []\n"
"    kwargs = []\n"
"    str_args = s.split()\n"
"    for str_arg in str_args:\n"
"        if '=' in str_arg:\n"
"            k, v = str_arg.split('=')\n"
"            kwargs.append((\n"
"                eval(repr(k), locals(), globals()),\n"
"                eval(v, locals(), globals())\n"
"            ))\n"
"        else:\n"
"            try:\n"
"                elem = eval(str_arg, locals(), globals())\n"
"            except SyntaxError:\n"
"                elem = eval(repr(str_arg), locals(), globals())\n"
"            if callable(elem):\n"
"                fs.append(elem)\n"
"            else:\n"
"                args.append(elem)\n"
"    return fs, args, kwargs\n"
"\n"
"identity = lambda x: x\n"
"\n"
"add = lambda x,y: x+y\n"
"\n"
"product = lambda x,y: x*y\n"
"\n"
"add100 = lambda x: x+100\n"
"\n"
"sub20 = lambda x: x-20\n"
"\n"
"div2 = lambda x: x/2\n"
"\n"
"mul2 = lambda x: x*2\n"
"\n"
"mul10 = lambda x: x*10\n"
"\n"
"mul5 = lambda x: x*5\n"
"\n"
"mul6 = lambda x: x*7\n"
"\n"
"sumargs = lambda *args, **kwargs: sum(args)\n"
"\n"
"sumvals = lambda *args, **kwargs: sum(v for (k,v) in kwargs.items())\n"
"\n"
"def shell(cmd: str, err_func=None):\n"
"    result = None\n"
"    try:\n"
"        elems = shlex.split(cmd)\n"
"        elems[-1] = os.path.expanduser(elems[-1])  \n"
"        result = subprocess.check_output(elems, encoding=\"utf8\").strip()\n"
"    except subprocess.CalledProcessError as e:\n"
"        if err_func:\n"
"            err_func(e.stderr)\n"
"    except FileNotFoundError as e:\n"
"        if err_func:\n"
"            err_func(e.strerror)\n"
"    if result:\n"
"        return result\n"
"\n"
"def out_dict(py_dict: dict):\n"
"\n"
"    res = []\n"
"    for k, v in py_dict.items():\n"
"        res.append(k)\n"
"        res.append(\":\")\n"
"        if type(v) in [list, set, tuple]:\n"
"            for i in v:\n"
"                res.append(i)\n"
"        else:\n"
"            res.append(v)\n"
"    return res\n"
"\n"
"def pipe(s: str):\n"
"\n"
"    fs, args, kwargs = __analyze(s)\n"
"    if args and fs:\n"
"        if len(args) == 1:\n"
"            arg = args[:].pop()\n"
"            for f in fs:\n"
"                arg = f(arg)\n"
"            return arg\n"
"        else:\n"
"            for f in fs:\n"
"                try:\n"
"                    args = list(map(f, args))\n"
"                except TypeError:\n"
"                    args = f(args)\n"
"            if args:\n"
"                return args\n"
"\n"
"def call(s: str):\n"
"\n"
"    fs, args, kwargs = __analyze(s)\n"
"    if len(fs) == 1:\n"
"        f = fs[0]\n"
"        try:\n"
"            return f(*args, **dict(kwargs))\n"
"        except TypeError:\n"
"            return f(args, **dict(kwargs))\n"
"\n"
"        return f(args[0])\n"
"\n"
"def fold(s: str):\n"
"\n"
"    fs, args, kwargs = __analyze(s)\n"
"    if len(fs) == 1:\n"
"        f = fs[0]\n"
"        accum, seq = args[0], args[1:]\n"
"        if len(seq) == 1:\n"
"            seq = seq[0]\n"
"        return functools.reduce(f, seq, accum)\n"
"    else:\n"
"        res = []\n"
"        for f in fs:\n"
"            accum, seq = args[0], args[1:]\n"
"            if len(seq) == 1:\n"
"                seq = seq[0]\n"
"            res.append(functools.reduce(f, seq, accum))\n"
"        return res\n"
"\n"
"def edit(path: str):\n"
"\n"
"    editor = os.getenv(\"EDITOR\", EDITOR)\n"
"    path = os.path.expanduser(path)\n"
"    shell(f\"open -a '{editor}' '{path}'\")\n"
"\n"
"\n";
