<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sta.20200602165810.1"><vh>project py</vh>
<v t="sta.20200602165801.1"><vh>@settings</vh>
<v t="sta.20200602165801.470"><vh>Import options</vh>
<v t="sta.20200602165801.471"><vh>@bool add-context-to-headlines = False</vh></v>
</v>
</v>
<v t="sta.20200602110822.1"><vh>py</vh>
<v t="sta.20200602164905.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20200602151837.1"><vh>notes</vh>
<v t="sta.20200602154708.1"><vh>@auto structure.txt</vh></v>
<v t="sta.20200602151900.1"><vh>@auto-md max-c-api.md</vh></v>
<v t="sta.20200602154130.1"><vh>@auto-md python-c-api.md</vh></v>
<v t="sta.20200602154301.1"><vh>@auto-md type-translation.md</vh></v>
<v t="sta.20200602154345.1"><vh>@auto-md repl.md</vh></v>
<v t="sta.20200602154429.1"><vh>@auto-md cython.md</vh></v>
<v t="sta.20200602154452.1"><vh>@auto-md packaging.md</vh></v>
<v t="sta.20200602154517.1"><vh>@auto-md scripting-tips.md</vh></v>
<v t="sta.20200602154626.1"><vh>@auto-md testing.md</vh></v>
</v>
<v t="sta.20200602164507.1"><vh>tests</vh>
<v t="sta.20200602164529.1"><vh>@clean test_translate.c</vh>
<v t="sta.20200602165143.1"><vh>declarations</vh></v>
<v t="sta.20200602165143.2"><vh>int main</vh></v>
<v t="sta.20200602165143.3"><vh>void handle_py_error</vh></v>
<v t="sta.20200602165143.4"><vh>int py_import</vh></v>
<v t="sta.20200602165143.5"><vh>int py_exec</vh></v>
<v t="sta.20200602165143.6"><vh>int py_execfile</vh></v>
<v t="sta.20200602165143.7"><vh>int py_run</vh></v>
<v t="sta.20200602165143.8"><vh>const char* py_eval_unicode</vh></v>
<v t="sta.20200602165301.1"><vh>long* py_eval_long_seq</vh></v>
<v t="sta.20200602165143.9"><vh>float* py_eval_float_seq</vh></v>
</v>
<v t="sta.20200602170210.1"><vh>@clean test_py.c</vh>
<v t="sta.20200602170222.1"><vh>declarations</vh></v>
<v t="sta.20200602170222.2"><vh>int main</vh></v>
<v t="sta.20200602170222.3"><vh>void py_import</vh></v>
<v t="sta.20200602170222.4"><vh>void py_run</vh></v>
<v t="sta.20200602170222.5"><vh>void py_execfile</vh></v>
<v t="sta.20200602170222.6"><vh>void py_exec</vh></v>
<v t="sta.20200602170222.7"><vh>void py_eval</vh></v>
</v>
<v t="sta.20200602170255.1"><vh>@clean test_py2.c</vh>
<v t="sta.20200602170336.1"><vh>typedef struct</vh></v>
<v t="sta.20200602170336.2"><vh>int main</vh></v>
<v t="sta.20200602170336.3"><vh>void handle_py_error</vh></v>
<v t="sta.20200602170336.4"><vh>void py_import</vh></v>
<v t="sta.20200602170336.5"><vh>void py_eval</vh></v>
<v t="sta.20200602170336.6"><vh>void py_exec</vh></v>
<v t="sta.20200602170336.7"><vh>void py_execfile</vh></v>
<v t="sta.20200602170336.8"><vh>void py_assign</vh></v>
<v t="sta.20200602170336.9"><vh>void py_anything</vh></v>
</v>
<v t="sta.20200602170358.1"><vh>@clean test_goto.c</vh>
<v t="sta.20200602170611.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170405.1"><vh>@clean test_args.c</vh>
<v t="sta.20200602170608.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170419.1"><vh>@clean test_arg2.c</vh>
<v t="sta.20200602170604.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170439.1"><vh>@clean test_string.c</vh>
<v t="sta.20200602170602.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170448.1"><vh>@clean test_print.c</vh>
<v t="sta.20200602170558.1"><vh>void printf2</vh></v>
<v t="sta.20200602170558.2"><vh>void sprintf2</vh></v>
<v t="sta.20200602170558.3"><vh>void test_sprintf2</vh></v>
<v t="sta.20200602170558.4"><vh>int main</vh></v>
</v>
<v t="sta.20200602170456.1"><vh>@clean test_minim.c</vh>
<v t="sta.20200602170556.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170513.1"><vh>@clean test_call.c</vh>
<v t="sta.20200602170550.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602174033.1"><vh>@clean test_interactive.c</vh>
<v t="sta.20200602174134.1"><vh>int main</vh></v>
</v>
<v t="sta.20200602170502.1"><vh>@clean test_demo.py</vh>
<v t="sta.20200602170553.1"><vh>Declarations</vh></v>
<v t="sta.20200602170553.2"><vh>module</vh></v>
<v t="sta.20200602170553.3"><vh>expression</vh></v>
<v t="sta.20200602170553.4"><vh>test_import</vh></v>
<v t="sta.20200602170553.5"><vh>test_import_error</vh></v>
<v t="sta.20200602170553.6"><vh>test_eval</vh></v>
</v>
</v>
<v t="sta.20200602110836.1"><vh>src</vh>
<v t="sta.20200602110841.1"><vh>@clean py.c</vh>
<v t="sta.20200602131126.1"><vh>includes</vh></v>
<v t="sta.20200602131131.1"><vh>globals</vh></v>
<v t="sta.20200602120540.1"><vh>helpers</vh>
<v t="sta.20200602120251.4"><vh>void py_log</vh></v>
<v t="sta.20200602120251.5"><vh>void py_error</vh></v>
<v t="sta.20200602120251.13"><vh>void py_handle_error</vh></v>
<v t="sta.20200606044751.1"><vh>void py_handle_output</vh></v>
</v>
<v t="sta.20200602120514.1"><vh>init &amp; free</vh>
<v t="sta.20200602120251.3"><vh>void ext_main</vh></v>
<v t="sta.20200602120251.7"><vh>void* py_new</vh></v>
<v t="sta.20200602120251.8"><vh>void py_init</vh></v>
<v t="sta.20200602120251.9"><vh>void py_free</vh></v>
</v>
<v t="sta.20200602121012.1"><vh>information</vh>
<v t="sta.20200602120251.10"><vh>void py_assist</vh></v>
<v t="sta.20200602122617.1"><vh>void py_count</vh></v>
</v>
<v t="sta.20200602122226.1"><vh>testing</vh>
<v t="sta.20200602122244.1"><vh>void py_bang</vh></v>
</v>
<v t="sta.20200602120447.1"><vh>editor</vh>
<v t="sta.20200602120251.14"><vh>void py_dblclick</vh></v>
<v t="sta.20200605120205.1"><vh>void py_locatefile</vh></v>
<v t="sta.20200602120251.15"><vh>void py_read</vh></v>
<v t="sta.20200602120251.16"><vh>void py_doread</vh></v>
<v t="sta.20200602120251.17"><vh>void py_edclose</vh></v>
<v t="sta.20200602120251.18"><vh>void py_edsave</vh></v>
<v t="sta.20200602120251.19"><vh>void py_load</vh></v>
</v>
<v t="sta.20200602120318.1"><vh>core</vh>
<v t="sta.20200602120251.20"><vh>void py_import</vh></v>
<v t="sta.20200602120251.21"><vh>void py_eval</vh></v>
<v t="sta.20200602120251.22"><vh>void py_exec</vh></v>
<v t="sta.20200602120251.23"><vh>void py_execfile</vh></v>
</v>
<v t="sta.20200602120740.1"><vh>extra</vh>
<v t="sta.20200605120324.1"><vh>void py_call</vh></v>
<v t="sta.20200602120251.24"><vh>void py_assign</vh></v>
<v t="sta.20200602120251.25"><vh>void py_anything</vh></v>
</v>
<v t="sta.20200606073716.1"><vh>interobject</vh>
<v t="sta.20200602120251.11"><vh>void py_scan</vh></v>
<v t="sta.20200603072826.1"><vh>long py_scan_callback</vh></v>
<v t="sta.20200602120251.12"><vh>void py_send</vh></v>
<v t="sta.20200602120251.26"><vh>void py_globex</vh></v>
</v>
</v>
<v t="sta.20200602145459.1"><vh>@clean py.h</vh>
<v t="sta.20200602150733.1"><vh>includes</vh></v>
<v t="sta.20200602150814.1"><vh>constants</vh></v>
<v t="sta.20200602145807.1"><vh>global variables</vh></v>
<v t="sta.20200602145517.1"><vh>object types</vh></v>
<v t="sta.20200602150052.1"><vh>function types</vh></v>
<v t="sta.20200602150129.1"><vh>enums</vh></v>
<v t="sta.20200602150250.1"><vh>macros</vh></v>
<v t="sta.20200602150324.1"><vh>methods</vh></v>
<v t="sta.20200602150415.1"><vh>helpers</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="sta.20200602110822.1"></t>
<t tx="sta.20200602110836.1">@path source/py</t>
<t tx="sta.20200602110841.1">// py.c

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602120251.10">void py_assist(t_py* x, void* b, long m, long a, char* s)
{
    if (m == ASSIST_INLET) { // inlet
        sprintf(s, "I am inlet %ld", a);
    } else { // outlet
        sprintf(s, "I am outlet %ld", a);
    }
}
</t>
<t tx="sta.20200602120251.11">void py_scan(t_py* x)
{
    long result = 0;

    hashtab_clear(py_global_registry);

    object_method(x-&gt;p_patcher, gensym("iterate"), 
        (method)py_scan_callback, x, PI_DEEP | PI_WANTBOX, &amp;result);
}

</t>
<t tx="sta.20200602120251.12">void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    // see:
    // https://cycling74.com/forums/error-handling-with-object_method_typed
    t_object* obj = NULL;
    char* obj_name = NULL;
    t_symbol* msg_sym = NULL;
    t_max_err err = NULL;

    // argv+0 is the object name
    obj_name = atom_getsym(argv)-&gt;s_name;
    if (obj_name == NULL) {
        goto error;
    }

    if (hashtab_getsize(py_global_registry) == 0) {
        py_scan(x);
    }

    // lifted from scheme-for-max (Thanks, Iain!)
    err = hashtab_lookup(py_global_registry, gensym(obj_name), &amp;obj);
    if (err || obj == NULL) {
        py_error(x, "no object found in the registry with the name %s",
                 obj_name);
        goto error;
    }

    // atom after the name of the destination
    switch ((argv + 1)-&gt;a_type) {
    case A_SYM: {
        msg_sym = atom_getsym(argv + 1);
        if (msg_sym == NULL) { // should check type here
            goto error;
        }
        // address the minimum case: e.g a bang
        if (argc - 2 == 0) { //
            argc = 0;
            argv = NULL;
        } else {
            argc = argc - 2;
            argv = argv + 2;
        }
        break;
    }
    case A_FLOAT: {
        msg_sym = gensym("float");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    case A_LONG: {
        msg_sym = gensym("int");
        if (msg_sym == NULL) { // should check type here
            goto error;
        }

        argc = argc - 1;
        argv = argv + 1;

        break;
    }
    default:
        py_log(x, "cannot process unknown type");
        break;
    }

    // methods to get method type
    // t_messlist* messlist = object_mess((t_object*)obj, msg_sym);
    // if (messlist) {
    //     post("messlist-&gt;m_sym  (name of msg): %s", messlist-&gt;m_sym-&gt;s_name);
    //     post("messlist-&gt;m_type (type of msg): %d", messlist-&gt;m_type[0]);        
    // }

    err = object_method_typed(obj, msg_sym, argc, argv, NULL);
    if (err) {
        py_error(x, "failed to send a message to object %s", obj_name);
        goto error;
    }

    // success
    return;

error:
    return;
}

</t>
<t tx="sta.20200602120251.13">void py_handle_error(t_py* x, char* fmt, ...)
{
    if (PyErr_Occurred()) {

        // build custom msg
        char msg[50];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        // get error info
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        PyErr_NormalizeException(&amp;ptype, &amp;pvalue, &amp;ptraceback);

        // PyObject* ptype_pstr = PyObject_Repr(ptype);
        // const char* ptype_str = PyUnicode_AsUTF8(ptype_pstr);
        Py_XDECREF(ptype);
        // Py_XDECREF(ptype_pstr);

        PyObject* pvalue_pstr = PyObject_Repr(pvalue);
        const char* pvalue_str = PyUnicode_AsUTF8(pvalue_pstr);
        Py_XDECREF(pvalue);
        Py_XDECREF(pvalue_pstr);

        Py_XDECREF(ptraceback);

        error("[py '%s'] &lt;- (%s): %s", x-&gt;p_name-&gt;s_name, msg, pvalue_str);
    }
}


</t>
<t tx="sta.20200602120251.14">void py_dblclick(t_py* x)
{
    if (x-&gt;p_code_editor)
        object_attr_setchar(x-&gt;p_code_editor, gensym("visible"), 1);
    else {
        x-&gt;p_code_editor = object_new(CLASS_NOBOX, gensym("jed"), x, 0);
        object_method(x-&gt;p_code_editor, gensym("settext"), *x-&gt;p_code,
                      gensym("utf-8"));
        object_attr_setchar(x-&gt;p_code_editor, gensym("scratch"), 1);
        object_attr_setsym(x-&gt;p_code_editor, gensym("title"),
                           gensym("py-editor"));
    }
}

</t>
<t tx="sta.20200602120251.15">void py_read(t_py* x, t_symbol* s)
{
    defer((t_object*)x, (method)py_doread, s, 0, NULL);
}

</t>
<t tx="sta.20200602120251.16">void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    t_fourcc filetype = FOUR_CHAR_CODE('TEXT'), outtype;
    char filename[MAX_PATH_CHARS];
    char pathname[MAX_PATH_CHARS];
    short path;
    t_max_err err;
    t_filehandle fh;

    if (s == gensym("")) { // if no arg supplied ask for file
        filename[0] = 0;
        
        if (open_dialog(filename, &amp;path, &amp;outtype, &amp;filetype, 1))
            // non-zero: cancelled
            return;

    } else {
        // must copy symbol before calling locatefile_extended
        strcpy(filename, s-&gt;s_name);
        if (locatefile_extended(filename, &amp;path, &amp;outtype, &amp;filetype, 1)) {
            // nozero: not found
            py_error(x, "can't find file %s", s-&gt;s_name);
            return;
        } else {
            err = path_toabsolutesystempath(path, filename, pathname);
        }

        // success
        // set attribute to pathname symbol
        x-&gt;p_code_filepath = gensym(pathname);
        err = path_opensysfile(filename, path, &amp;fh, READ_PERM);
        if (!err) {
            sysfile_readtextfile(fh, x-&gt;p_code, 0,
                                 TEXT_LB_UNIX | TEXT_NULL_TERMINATE);
            sysfile_close(fh);
            x-&gt;p_code_size = sysmem_handlesize(x-&gt;p_code);
        }
    }
}

</t>
<t tx="sta.20200602120251.17">void py_edclose(t_py* x, char** text, long size)
{
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    x-&gt;p_code = sysmem_newhandleclear(size + 1);
    sysmem_copyptr((char*)*text, *x-&gt;p_code, size);
    x-&gt;p_code_size = size + 1;
    x-&gt;p_code_editor = NULL;
}

</t>
<t tx="sta.20200602120251.18">void py_edsave(t_py* x, char** text, long size)
{
    PyObject* pval = NULL;

    if (text == NULL) {
        goto error;
    }

    pval = PyRun_String(*text, Py_file_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);
    return;

error:
    py_handle_error(x, "edclose-exec %s", x-&gt;p_code_filepath-&gt;s_name);
    Py_XDECREF(pval);
}

</t>
<t tx="sta.20200602120251.19">void py_load(t_py* x, t_symbol* s)
{
    if (s == gensym("")) {
        if (x-&gt;p_code_filepath != gensym("")) {
            py_read(x, x-&gt;p_code_filepath);
            py_execfile(x, x-&gt;p_code_filepath);
            return;
        }
    } else {
        py_read(x, s);
        py_execfile(x, s);
    }
}

</t>
<t tx="sta.20200602120251.20">void py_import(t_py* x, t_symbol* s)
{
    PyObject* x_module = NULL;

    if (s != gensym("")) {
        x_module = PyImport_ImportModule(s-&gt;s_name);
        // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, s-&gt;s_name, x_module);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "imported: %s", s-&gt;s_name);
    }
    return;
error:
    py_handle_error(x, "import %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.21">void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    py_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(py_argv, Py_eval_input, 
        x-&gt;p_globals, x-&gt;p_globals);

    if (pval != NULL) {
        py_handle_output(x, pval);
        return;
    } else {
        py_handle_error(x, "eval %s", py_argv);
    }
}

</t>
<t tx="sta.20200602120251.22">void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* pval = NULL;
    t_max_err err;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "exec %s", text);
    } else {
        goto error;
    }

    pval = PyRun_String(text, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        sysmem_freeptr(text);
        goto error;
    }

    // success cleanup
    sysmem_freeptr(text);
    Py_DECREF(pval);
    // success bang
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "exec failed");
    Py_XDECREF(pval);
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.23">void py_execfile(t_py* x, t_symbol* s)
{
    /*
    IMPORTANT: do not use post, logging or error, error
    handler to which uses name of file during debugging or error
    report as it will crash due to underlying 'sprintf' mechanism
    not handling (even quoted) paths with a space inside!
    */

    t_symbol* pathname = gensym("");
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s == gensym("")) {
        if (x-&gt;p_code_filepath == gensym("")) {
            py_error(x, "py execfile: missing filepath");
            goto error;
        } else {
            pathname = x-&gt;p_code_filepath;
        }
    } else {
        pathname = s;
    }

    fhandle = fopen(pathname-&gt;s_name, "r+");

    if (fhandle == NULL) {
        py_error(x, "could not open file");
        goto error;
    }

    pval = PyRun_File(fhandle, pathname-&gt;s_name, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "execfile");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.24">void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    char* varname = NULL;
    PyObject* list = NULL;

    if (s != gensym(""))
        py_log(x, "s: %s", s-&gt;s_name);

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        // strncpy_zero(varname, atom_getsym(argv)-&gt;s_name, 50);
        varname = atom_getsym(argv)-&gt;s_name;
        py_log(x, "varname: %s", varname);
    }

    if ((list = PyList_New(0)) == NULL) {
        py_error(x, "list == NULL");
        goto error;
    }

    // NOTE: n C itâ€™s illegal to have a declaration as the first statement
    // after a label enclosing the whole subblock in a {} seems to work
    for (int i = 1; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                error("p_float == NULL");
                goto error;
            }
            PyList_Append(list, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(list, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(list, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(list) != argc - 1) {
        py_error(x, "PyList_Size(list) != argc - 1");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(list));
    }

    // finally, assign list to varname in object namespace
    py_log(x, "setting %s to list in namespace", varname);
    int res = PyDict_SetItemString(x-&gt;p_globals, varname, list);
    if (res != 0) {
        py_error(x, "assign varname to list failed");
        goto error;
    }
    // Py_XDECREF(list); // causes a crash
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:
    py_handle_error(x, "assign %s", s-&gt;s_name);
    Py_XDECREF(list);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.25">void py_anything(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    PyObject* pval = NULL;
    PyObject* py_callable = NULL;
    PyObject* py_argslist = NULL; // python list
    PyObject* py_args = NULL;     // python tuple

    if (s == gensym("")) {
        py_error(x, "could not retrieve callable name", s-&gt;s_name);
        goto error;
    }

    py_callable = PyRun_String(s-&gt;s_name, Py_eval_input, x-&gt;p_globals,
                               x-&gt;p_globals);
    if (py_callable == NULL) {
        py_error(x, "could not evaluate '%s'", s-&gt;s_name);
        goto error;
    }

    if (!PyCallable_Check(py_callable)) {
        pval = py_callable;
        goto handle_output;
    }

    if ((py_argslist = PyList_New(0)) == NULL) {
        py_error(x, "could not create an empty python list");
        goto error;
    }

    for (int i = 0; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                py_error(x, "p_float == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(py_argslist) != argc) {
        py_error(x, "PyList_Size(list) != argc");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(py_argslist));
    }

    // convert py_args to tuple
    py_args = PyList_AsTuple(py_argslist);
    if (py_args == NULL) {
        py_error(x, "unable to convert args list to tuple");
        goto error;
    }

    // pval = PyObject_Call(py_callable, py_args, NULL);
    pval = PyObject_CallObject(py_callable, py_args);
    if (!PyErr_ExceptionMatches(PyExc_TypeError)) {
        if (pval == NULL) {
            py_error(x, "unable to apply callable(*args)");
            goto error;
        }
        goto handle_output;
    }
    PyErr_Clear();

    pval = PyObject_CallFunctionObjArgs(py_callable, py_argslist, NULL);
    if (pval == NULL) {
        py_error(x, "could not retrieve result of callable(list)");
        goto error;
    }
    goto handle_output; // this is redundant but safe


handle_output:

    py_handle_output(x, pval);
    // success cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    py_log(x, "END %s", s-&gt;s_name);
    outlet_bang(x-&gt;p_outlet_right);
    return;

error:

    py_handle_error(x, "anything %s", s-&gt;s_name);
    // cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200602120251.26">void py_globex(t_py* x, long n)
{
    PyObject* globex_mod = NULL;

    globex_mod = PyImport_ImportModule("globex"); // x_module borrrowed ref
    if (globex_mod == NULL) {
        goto error;
    }

    PyDict_SetItemString(x-&gt;p_globals, "globex", globex_mod);

    PyObject* globex_dict = PyModule_GetDict(globex_mod);

    if (PyDict_SetItemString(globex_dict, NAME_INT, PyLong_FromLong(n))
        == -1) {
        py_error(x, "cannot set long to NAME_INT");
        goto error;
    }

    outlet_bang(x-&gt;p_outlet_right);
    py_log(x, "globex import and globex.INT = %ld", n);
    return;
error:
    py_handle_error(x, "globex %ld", n);
    outlet_bang(x-&gt;p_outlet_middle);
}
</t>
<t tx="sta.20200602120251.3">void ext_main(void* r)
{
    t_class* c;

    c = class_new("py", (method)py_new, (method)py_free, (long)sizeof(t_py),
                  0L, A_GIMME, 0);

    // object methods
    //------------------------------------------------------------------------
    // clang-format off
     

    // testing
    class_addmethod(c, (method)py_bang,       "bang",       0);
    class_addmethod(c, (method)py_call,       "call",       A_GIMME,  0);

    // core python
    class_addmethod(c, (method)py_import,     "import",     A_SYM,    0);
    class_addmethod(c, (method)py_eval,       "eval",       A_GIMME,  0);
    class_addmethod(c, (method)py_exec,       "exec",       A_GIMME,  0);
    class_addmethod(c, (method)py_execfile,   "execfile",   A_DEFSYM, 0);

    // extra python
    class_addmethod(c, (method)py_assign,     "assign",     A_GIMME,  0);
    class_addmethod(c, (method)py_anything,   "anything",   A_GIMME,  0);
    class_addmethod(c, (method)py_globex,     "globex",     A_LONG,   0);
    
    /* you CAN'T call this from the patcher */
    class_addmethod(c, (method)py_assist,     "assist",     A_CANT, 0);

    // meta
    class_addmethod(c, (method)py_count,      "count",      A_NOTHING, 0);
    class_addmethod(c, (method)py_scan,       "scan",       A_NOTHING, 0);
    class_addmethod(c, (method)py_send,       "send",       A_GIMME,   0);

    // code editor
    class_addmethod(c, (method)py_read,       "read",       A_DEFSYM, 0);
    class_addmethod(c, (method)py_dblclick,   "dblclick",   A_CANT,   0);
    class_addmethod(c, (method)py_edclose,    "edclose",    A_CANT,   0);
    class_addmethod(c, (method)py_edsave,     "edsave",     A_CANT,   0);
    class_addmethod(c, (method)py_load,       "load",       A_DEFSYM, 0);

    // attributes
    CLASS_ATTR_ORDER(c, "name", 0,  "1");
    CLASS_ATTR_LABEL(c, "name", 0,  "unique object id");
    CLASS_ATTR_SYM(c,   "name", 0,   t_py, p_name);
    CLASS_ATTR_BASIC(c, "name", 0);
    // CLASS_ATTR_INVISIBLE(c, "name", 0);

    CLASS_ATTR_ORDER(c,  "file", 0,  "2");
    CLASS_ATTR_LABEL(c,  "file", 0,  "default python script");
    CLASS_ATTR_SYM(c,    "file", 0,   t_py,  p_code_filepath);
    // CLASS_ATTR_STYLE(c,  "file", 0,   "file");
    CLASS_ATTR_BASIC(c,  "file", 0);
    CLASS_ATTR_SAVE(c,   "file", 0);

    CLASS_ATTR_ORDER(c,  "pythonpath", 0,  "3");
    CLASS_ATTR_LABEL(c,  "pythonpath", 0,  "per-object pythonpath");
    CLASS_ATTR_SYM(c,    "pythonpath", 0,  t_py, p_pythonpath);
    CLASS_ATTR_STYLE(c,  "pythonpath", 0,  "file");
    CLASS_ATTR_BASIC(c,  "pythonpath", 0);
    CLASS_ATTR_SAVE(c,   "pythonpath", 0);

    CLASS_ATTR_ORDER(c,  "debug", 0,  "4");
    CLASS_ATTR_LABEL(c,  "debug", 0,  "debug log to console");
    CLASS_ATTR_CHAR(c,   "debug", 0,  t_py, p_debug);
    CLASS_ATTR_STYLE(c,  "debug", 0, "onoff");
    CLASS_ATTR_BASIC(c,  "debug", 0);
    CLASS_ATTR_SAVE(c,   "debug", 0);

    // clang-format on
    //------------------------------------------------------------------------

    class_register(CLASS_BOX, c);

    /* for js registration (can't be both box and nobox) */
    // c-&gt;c_flags = CLASS_FLAG_POLYGLOT;
    // class_register(CLASS_NOBOX, c);

    py_class = c;
}

</t>
<t tx="sta.20200602120251.4">void py_log(t_py* x, char* fmt, ...)
{
    if (x-&gt;p_debug) {
        char msg[50];

        va_list va;
        va_start(va, fmt);
        vsprintf(msg, fmt, va);
        va_end(va);

        post("[py '%s']: %s", x-&gt;p_name-&gt;s_name, msg);
    }
}

</t>
<t tx="sta.20200602120251.5">void py_error(t_py* x, char* fmt, ...)
{
    char msg[50];

    va_list va;
    va_start(va, fmt);
    vsprintf(msg, fmt, va);
    va_end(va);

    error("[py '%s']: %s", x-&gt;p_name-&gt;s_name, msg);
}

</t>
<t tx="sta.20200602120251.7">void* py_new(t_symbol* s, long argc, t_atom* argv)
{
    t_py* x = NULL;

    x = (t_py*)object_alloc(py_class);

    if (x) {
        // core
        if (py_global_obj_count == 0) {
            x-&gt;p_name = gensym("__main__"); // first is __main__
        } else {
            x-&gt;p_name = symbol_unique();
        }

        // communication
        x-&gt;p_patcher = NULL;
        x-&gt;p_box = NULL;

        // python-related
        x-&gt;p_pythonpath = gensym("");
        x-&gt;p_debug = 1;

        // text editor
        x-&gt;p_code = sysmem_newhandle(0);
        x-&gt;p_code_size = 0;
        x-&gt;p_code_editor = NULL;
        x-&gt;p_code_filepath = gensym("");

        // create inlet(s)
        // create outlet(s)
        x-&gt;p_outlet_right = outlet_new(x, NULL);
        x-&gt;p_outlet_middle = outlet_new(x, NULL);
        x-&gt;p_outlet_left = outlet_new(x, NULL);

        // process @arg attributes
        attr_args_process(x, argc, argv);

        object_obex_lookup(x, gensym("#P"), (t_patcher**)&amp;x-&gt;p_patcher);
        if (x-&gt;p_patcher == NULL)
            error("patcher object not created.");

        object_obex_lookup(x, gensym("#B"), (t_box**)&amp;x-&gt;p_box);
        if (x-&gt;p_box == NULL)
            error("patcher object not created.");

        // python init
        py_init(x);

        py_log(x, "object created");
        for (int i = 0; i &lt; argc; i++) {
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            post("argc: %d  argv: %s", i, atom_getsym(argv + i)-&gt;s_name);
        }
    }

    return (x);
}

</t>
<t tx="sta.20200602120251.8">void py_init(t_py* x)
{
    // wchar_t *program;

    // program = Py_DecodeLocale(argv[0], NULL);
    // program = Py_DecodeLocale("py", NULL);
    // if (program == NULL) {
    //     exit(1);
    // }

    /* Add the cythonized 'api' built-in module, before Py_Initialize */
    if (PyImport_AppendInittab("api", PyInit_api) == -1) {
        py_error(x, "could not add 'api' to builtin modules table");
    }

    if (PyImport_AppendInittab("globex", PyInit_globex) == -1) {
        py_error(x, "could not add 'globex' to builtin modules table");
    }

    // Py_SetProgramName(program);

    Py_Initialize();

    // python init
    PyObject* main_mod = PyImport_AddModule(x-&gt;p_name-&gt;s_name); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_mod); // borrowed reference
    PyDict_SetItemString(x-&gt;p_globals, "__builtins__", PyEval_GetBuiltins());

    /* start: add additional python objects to the globals dict here */
    /* end */

    // py_log(x, "globals initialized");
    object_register(CLASS_BOX, x-&gt;p_name, x);
    // py_log(x, "object registered");

    // increment global object counter
    py_global_obj_count++;

    if (py_global_obj_count == 1) {
        // if first py object create the py_global_registry;
        py_global_registry = (t_hashtab*)hashtab_new(0);
        hashtab_flags(py_global_registry, OBJ_FLAG_REF);
    }
}

</t>
<t tx="sta.20200602120251.9">void py_free(t_py* x)
{
    // code editor cleanup
    object_free(x-&gt;p_code_editor);
    if (x-&gt;p_code)
        sysmem_freehandle(x-&gt;p_code);

    // python objects cleanup
    py_log(x, "will be deleted");
    py_global_obj_count--;
    if (py_global_obj_count == 0) {
        /* WARNING: don't call x here or max will crash */
        hashtab_chuck(py_global_registry);

        post("last py obj freed -&gt; finalizing py mem / interpreter.");
        // PyMem_RawFree(program);
        Py_FinalizeEx();
    }
}

</t>
<t tx="sta.20200602120318.1">/*--------------------------------------------------------------------------*/
// CORE

</t>
<t tx="sta.20200602120447.1">/*--------------------------------------------------------------------------*/
// EDITOR

</t>
<t tx="sta.20200602120514.1">/*--------------------------------------------------------------------------*/
// INIT &amp; FREE

</t>
<t tx="sta.20200602120540.1">/*--------------------------------------------------------------------------*/
// HELPERS

</t>
<t tx="sta.20200602120740.1">/*--------------------------------------------------------------------------*/
// EXTRA

</t>
<t tx="sta.20200602121012.1">/*--------------------------------------------------------------------------*/
// DOCUMENTATION

</t>
<t tx="sta.20200602122226.1">/*--------------------------------------------------------------------------*/
// TESTING
</t>
<t tx="sta.20200602122244.1">
void py_bang(t_py* x)
{
    // just a basic bang out the left outlet method
    outlet_bang(x-&gt;p_outlet_left);
}

</t>
<t tx="sta.20200602122617.1">
void py_count(t_py* x) { outlet_int(x-&gt;p_outlet_left, py_global_obj_count); }
</t>
<t tx="sta.20200602131126.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* py external api */
#include "py.h"

/* max/msp api */
#include "api.h"
#include "globex.h"

</t>
<t tx="sta.20200602131131.1">/*--------------------------------------------------------------------------*/
// GLOBALS

t_class* py_class; // global pointer to object class

static int py_global_obj_count = 0; // when 0 then free interpreter

static t_hashtab* py_global_registry = NULL; // global object lookups

// static wchar_t* program;

</t>
<t tx="sta.20200602145459.1">#ifndef PY_H
#define PY_H

/* py.h */

@others
@language c
@tabwidth -4

#endif // PY_H
</t>
<t tx="sta.20200602145517.1">/*--------------------------------------------------------------------------*/
// OBJECT TYPES

typedef struct _py {
    /* object header */
    t_object p_ob;

    /* object attributes */
    t_symbol* p_name; /* unique object name (not scripting name) */

    /* python-related */
    t_symbol* p_pythonpath; /* path to python directory */
    t_bool p_debug;         /* bool to switch per-object debug state */
    // int p_debug;
    PyObject* p_globals; /* global python namespace (new ref) */

    /* infra objects */
    t_patcher* p_patcher; /* to send msgs to objects */
    t_box* p_box;         /* the ui box of the py instance? */

    /* text editor attrs */
    t_object* p_code_editor;
    char** p_code;
    long p_code_size;
    t_symbol* p_code_filepath; /* default python filepath to load into
                                  the code editor and global namespace */
    /* outlet creation */
    void* p_outlet_right;  // right outlet to bang success
    void* p_outlet_middle; // middle outleet to bang error
    void* p_outlet_left;   // left outleet for msg output

} t_py;

</t>
<t tx="sta.20200602145807.1">/*--------------------------------------------------------------------------*/
// GLOBALS

static int py_global_obj_count;
</t>
<t tx="sta.20200602150052.1">/*--------------------------------------------------------------------------*/
// FUNCTION TYPES
</t>
<t tx="sta.20200602150129.1">/*--------------------------------------------------------------------------*/
// ENUMS

/* python execution mode */
typedef enum { PY_EVAL, PY_EXEC, PY_EXECFILE } py_mode;
</t>
<t tx="sta.20200602150250.1">/*--------------------------------------------------------------------------*/
// MACROS

#define foreach(i, n)                                                         \
    int i;                                                                    \
    for (i = 0; i &lt; n; i++)
</t>
<t tx="sta.20200602150324.1">/*--------------------------------------------------------------------------*/
// METHODS

/* object creation and destruction */
void* py_new(t_symbol* s, long argc, t_atom* argv);
void py_free(t_py* x);

/* core python methods */
void py_import(t_py* x, t_symbol* s);
void py_eval(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_exec(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_execfile(t_py* x, t_symbol* s);

/* extra python methods */
// void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_assign(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_anything(t_py* x, t_symbol* s, long argc, t_atom* argv);

/* documentation and meta info */
void py_count(t_py* x);
void py_assist(t_py* x, void* b, long m, long a, char* s);

/* code editor */
void py_read(t_py* x, t_symbol* s);
void py_doread(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_dblclick(t_py* x);
void py_edclose(t_py* x, char** text, long size);
void py_edsave(t_py* x, char** text, long size);
void py_load(t_py* x, t_symbol* s); // combo of read -&gt; execfile

/* used for testing */
void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_bang(t_py* x);
void py_scan(t_py* x);
long py_scan_callback(t_py* x, t_object* obj);
void py_send(t_py* x, t_symbol* s, long argc, t_atom* argv);
void py_globex(t_py* x, long n);
</t>
<t tx="sta.20200602150415.1">/*--------------------------------------------------------------------------*/
// HELPERS

void py_init(t_py* x);
void py_locatefile(t_py* x, char* filename);
void py_log(t_py* x, char* fmt, ...);
void handle_py_error(t_py* x, char* fmt, ...);
</t>
<t tx="sta.20200602150733.1">/*--------------------------------------------------------------------------*/
// INCLUDES

/* max api */
#include "ext.h"
#include "ext_obex.h"

/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
</t>
<t tx="sta.20200602150814.1">/*--------------------------------------------------------------------------*/
// CONSTANTS

#define PY_MAX_ATOMS 128
#define PY_MAX_NAME "PY_NAME"
//#define PY_NAMESPACE "PY_SPACE"
#define MAX_IMPORTS 3
</t>
<t tx="sta.20200602151837.1">@path source/py/notes</t>
<t tx="sta.20200602164507.1">@path source/py/tests
</t>
<t tx="sta.20200602164529.1">/* python */

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;



@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602165143.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;


#define PY_MAX_LONG 256
#define PY_MAX_FLOAT PY_MAX_LONG

/* --------------------------------------- */
// forward func declarations

int py_import(t_py* x, char* args);
// int py_eval(t_py* x, char* args);
int py_exec(t_py* x, char* args);
int py_execfile(t_py* x, char* args);
int py_run(t_py* x, char* args);

</t>
<t tx="sta.20200602165143.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* module = PyImport_AddModule("__main__"); // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        // if (strcmp(argv[1], "eval") == 0)
        //     py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run] args\n");
    }

    Py_FinalizeEx();
    return 0;
}


</t>
<t tx="sta.20200602165143.3">void handle_py_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}

</t>
<t tx="sta.20200602165143.4">int py_import(t_py* x, char* name)
{
    PyObject* x_module = NULL;

    if (name != NULL) {
        x_module = PyImport_ImportModule(name); // x_module borrrowed ref
        if (x_module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, name, x_module);
        return 0;
    }

error:
    handle_py_error();
    return -1;
}

</t>
<t tx="sta.20200602165143.5">int py_exec(t_py* x, char* statement)
{
    PyObject* pval = NULL;

    if (statement == NULL) {
        goto error;
    }

    pval = PyRun_String(statement, Py_single_input, x-&gt;p_globals,
                        x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}

</t>
<t tx="sta.20200602165143.6">int py_execfile(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (fpath == NULL) {
        goto error;
    }

    fhandle = fopen(fpath, "r");
    if (fhandle == NULL) {
        goto error;
    }

    pval = PyRun_File(fhandle, fpath, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);

    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.7">int py_run(t_py* x, char* fpath)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (fpath == NULL) {
        goto error;
    }

    pval = Py_BuildValue("s", fpath); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, fpath);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);
    return 0;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


PyObject* py_eval_obj(t_py* x, char* expression)
{
    PyObject* pval = PyRun_String(expression, Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);
    if (pval != NULL) {
        return pval;
    } else {
        handle_py_error();
        return NULL;
    }
}


long py_eval_long(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyLong_Check(pval)) {
        goto error;
    }

    long result = PyLong_AsLong(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


double py_eval_double(t_py* x, char* expression)
{

    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyFloat_Check(pval)) {
        goto error;
    }

    double result = PyFloat_AsDouble(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return -1;
}


</t>
<t tx="sta.20200602165143.8">const char* py_eval_unicode(t_py* x, char* expression)
{
    PyObject* pval = NULL;

    pval = py_eval_obj(x, expression);

    if (pval == NULL) {
        goto error;
    }

    if (!PyUnicode_Check(pval)) {
        goto error;
    }

    const char* result = PyUnicode_AsUTF8(pval);

    Py_XDECREF(pval);
    return result;

error:
    handle_py_error();
    Py_XDECREF(pval);
    return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165143.9">float* py_eval_float_seq(t_py* x, char* expression)
{
    // caller must free
    float *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
    }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (float*)calloc(length, sizeof(float));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyFloat_Check(item)) {
                if (PyFloat_AsDouble(item) != -1) {
                    result[i] = (float)PyFloat_AsDouble(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}
// caller must free
</t>
<t tx="sta.20200602165301.1">long* py_eval_long_seq(t_py* x, char* expression)
{
    // caller must free
    long *result;
    PyObject* iter = NULL;
    PyObject* item = NULL;
    int i = 0;

    PyObject* pval = py_eval_obj(x, expression);
    if (pval == NULL) {
        goto error;
    }

    if (!PySequence_Check(pval)) {
        goto error;
     }

    Py_ssize_t length = PySequence_Length(pval);
    if (length == -1) {
        goto error;
    }

    // use calloc instead of malloc to init zeros
    result = (long*)calloc(length, sizeof(long));
    if (result == NULL) {
        goto error;
    }

    if ((iter = PyObject_GetIter(pval)) != NULL) {
        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                if (PyLong_AsLong(item) != -1) {
                    result[i] = PyLong_AsLong(item);
                    i++;              
                }    
            }
            Py_DECREF(item);
        }
    }

    // success
    Py_XDECREF(pval);
    return result; // caller must free

    error:
        handle_py_error();
        Py_XDECREF(pval);
        return NULL;
}

// caller must free
</t>
<t tx="sta.20200602165801.1">@language rest
@wrap

This @settings tree contains all active settings.

Settings outside this tree have no effect.

The node "Qt Gui Stylesheet settings" contains most of the setting relating to appearance.
</t>
<t tx="sta.20200602165801.470">@language rest
@wrap

</t>
<t tx="sta.20200602165801.471">If True, names uses headline "Foo.bar" for bar() defined in class
Foo, and headline "bar (foo.py)" for bar() defined at top level in
foo.py.  This is useful if you've cloned the node so its origin is
not obvious from context.

If False, does not do the above, useful if you don't use clones
and don't want the visual clutter of repeated class / file names.</t>
<t tx="sta.20200602165810.1"></t>
<t tx="sta.20200602170210.1">
/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;


@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170222.1">/* --------------------------------------- */
// types

typedef struct _py {
    PyObject* p_globals;
} t_py;

/* --------------------------------------- */
// forward func declarations

void py_import(t_py* x, char* args);
void py_eval(t_py* x, char* args);
void py_exec(t_py* x, char* args);
void py_execfile(t_py* x, char* args);
void py_run(t_py* x, char* args);

</t>
<t tx="sta.20200602170222.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* main_module = PyImport_AddModule(
        "__main__");                              // borrowed reference
    x-&gt;p_globals = PyModule_GetDict(main_module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argv[2]);
        if (strcmp(argv[1], "eval") == 0)
            py_eval(x, argv[2]);
        if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argv[2]);
        if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argv[2]);
        if (strcmp(argv[1], "run") == 0)
            py_run(x, argv[2]);
    } else {
        printf("usage: test [import, eval, exec, execfile, run] args\n");
    }

    Py_FinalizeEx();
    return 0;
}

//--------------------------------------------------------------------------

</t>
<t tx="sta.20200602170222.3">void py_import(t_py* x, char* args)
{
    PyObject* x_module = NULL;

    if (args != NULL) {
        x_module = PyImport_ImportModule(args); // x_module borrrowed ref
        if (x_module == NULL) {
            PyErr_SetString(PyExc_ImportError, "Ooops again.");
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, args, x_module);
        printf("imported: %s\n", args);
    }
    // else goto error;

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('import %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
        // Py_XDECREF(x_module);
    }
}

</t>
<t tx="sta.20200602170222.4">void py_run(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;
    int ret = 0;

    if (args == NULL) {
        printf("%s: could not retrieve args\n", args);
        goto error;
    }

    pval = Py_BuildValue("s", args); // new reference
    if (pval == NULL) {
        goto error;
    }

    fhandle = _Py_fopen_obj(pval, "r+");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    ret = PyRun_SimpleFile(fhandle, args);
    if (ret == -1) {
        goto error;
    }

    // success
    fclose(fhandle);
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('run %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.5">void py_execfile(t_py* x, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (args == NULL) {
        printf("execfile: could not retrieve arg: %s\n", args);
        goto error;
    }

    fhandle = fopen(args, "r");
    if (fhandle == NULL) {
        printf("could not open file '%s'\n", args);
        goto error;
    }

    pval = PyRun_File(fhandle, args, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        fclose(fhandle);
        goto error;
    }

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('execfile %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.6">void py_exec(t_py* x, char* args)
{
    PyObject* pval = NULL;

    if (args == NULL) {
        printf("exec: could not retrieve args: %s\n", args);
        goto error;
    }

    pval = PyRun_String(args, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }

    // success cleanup
    Py_DECREF(pval);

error:
    if (PyErr_Occurred()) {
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('exec %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(pval);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
}

</t>
<t tx="sta.20200602170222.7">void py_eval(t_py* x, char* args)
{
    PyObject* pval = NULL;
    PyObject* locals = NULL;

    if (args == NULL) {
        printf("eval: could not retrieve quoted args: %s\n", args);
        goto error;
    }

    locals = PyDict_New();
    if (locals == NULL) {
        goto error;
    }

    pval = PyRun_String(args, Py_eval_input, x-&gt;p_globals, locals);
    if (pval == NULL) {
        goto error;
    }

    // handle ints and longs
    if (PyLong_Check(pval)) {
        long int_result = PyLong_AsLong(pval);
        printf("int: %ld\n", int_result);
    }

    // handle floats and doubles
    if (PyFloat_Check(pval)) {
        float float_result = (float)PyFloat_AsDouble(pval);
        printf("int: %f\n", float_result);
    }

    // handle strings
    if (PyUnicode_Check(pval)) {
        const char* unicode_result = PyUnicode_AsUTF8(pval);
        printf("unicode: %s\n", unicode_result);
    }

    // handle lists, tuples and sets
    if (PyList_Check(pval) || PyTuple_Check(pval) || PyAnySet_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);
        if (seq_size &lt;= 0) {
            printf("cannot convert python sequence with zero or less length");
            goto error;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                printf("%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                printf("%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                printf("%d unicode: %s\n", i, unicode_item);
                i++;
            }
            Py_DECREF(item);
        }
        printf("end iter op: %d\n", i);
    }

    // success cleanup
    Py_XDECREF(pval);
    // Py_XDECREF(locals);
    return;

error:
    if (PyErr_Occurred()) {
        // PyErr_Print();
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);

        // get error message
        const char* pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
        printf("PyException('eval %s'): %s\n", args, pStrErrorMessage);
        Py_XDECREF(ptype);
        Py_XDECREF(pvalue);
        Py_XDECREF(ptraceback);
    }
    // else if (PyErr_ExceptionMatches (PyExc_SyntaxError)) {
    //     // PyErr_Print ();
    //     PyObject *ptype, *pvalue, *ptraceback;
    //     PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);

    //     // get error message
    //     const char *pStrErrorMessage = PyUnicode_AsUTF8(pvalue);
    //     printf("PyException('eval %s'): %s\n", args, pStrErrorMessage);
    //     Py_DECREF(ptype);
    //     Py_DECREF(pvalue);
    //     Py_DECREF(ptraceback);
    // }
    // cleanup
    Py_XDECREF(pval);
    // Py_XDECREF(locals);
}
</t>
<t tx="sta.20200602170255.1">
/* python */
#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

/* --------------------------------------- */
// types

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170336.1">typedef struct _py {
    PyObject* p_globals;
} t_py;

/* --------------------------------------- */
// forward func declarations

void py_import(t_py* x, int argc, char* argv);
void py_eval(t_py* x, int argc, char* argv);
void py_exec(t_py* x, int argc, char* argv);
void py_execfile(t_py* x, int argc, char* argv);
void py_assign(t_py* x, int argc, char* argv);
void py_anything(t_py* x, int argc, char* argv);
void handle_py_error(void);

</t>
<t tx="sta.20200602170336.2">int main(int argc, char* argv[])
{
    t_py obj = { .p_globals = NULL };
    t_py* x = &amp;obj;

    Py_Initialize();

    // python init
    PyObject* main_module = PyImport_AddModule("__main__"); // borrowed
    x-&gt;p_globals = PyModule_GetDict(main_module); // borrowed reference

    if (argc &gt; 2) {
        if (strcmp(argv[1], "import") == 0)
            py_import(x, argc, argv);
        else if (strcmp(argv[1], "eval") == 0)
            py_eval(x, argc, argv);
        else if (strcmp(argv[1], "exec") == 0)
            py_exec(x, argc, argv);
        else if (strcmp(argv[1], "execfile") == 0)
            py_execfile(x, argc, argv);
        else if (strcmp(argv[1], "assign") == 0)
            py_assign(x, argc, argv);
        else py_anything(x, argc, argv);

    } else {
        printf("usage: test [import, eval, exec, execfile, assign, ...] args\n");
    }

    Py_FinalizeEx();
    return 0;
}


/* python error handler helper function */
</t>
<t tx="sta.20200602170336.3">void handle_py_error(void)
{
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
}


/*--------------------------------------------------------------------------*/
// core python methods

</t>
<t tx="sta.20200602170336.4">void py_import(t_py* x, int argc, char* argv[])
{
    PyObject* module = NULL;

    if (argv != NULL) {
        module = PyImport_ImportModule(argv[2]); // module borrrowed ref
        if (module == NULL) {
            goto error;
        }
        PyDict_SetItemString(x-&gt;p_globals, argv[2], module);
        printf("imported: %s\n", argv[2]);
    }
    return;
error:
    handle_py_error();
}


// see: https://codereview.stackexchange.com/questions/71970/creating-a-string-from-command-line-arguments
// see also: (how last entry should be null terminated e.g. filename[63] = '\0';)
// https://stackoverflow.com/questions/19194254/how-can-i-copy-the-contents-of-argv-into-a-c-style-string


</t>
<t tx="sta.20200602170336.5">void py_eval(t_py* x, int argc, char* argv[])
{
    char* py_argv = atom_getsym(argv)-&gt;s_name;
    py_log(x, "%s %s", s-&gt;s_name, py_argv);

    PyObject* pval = PyRun_String(argv[2], Py_eval_input, x-&gt;p_globals,
                                  x-&gt;p_globals);

    if (pval != NULL) {

        // handle ints and longs
        if (PyLong_Check(pval)) {
            long int_result = PyLong_AsLong(pval);
        }

        // handle floats and doubles
        if (PyFloat_Check(pval)) {
            float float_result = (float)PyFloat_AsDouble(pval);
        }

        // handle strings
        if (PyUnicode_Check(pval)) {
            const char* unicode_result = PyUnicode_AsUTF8(pval);

        }

        // handle any sequence except strings, and presently
        // bytes and byte arrays (until there is a reason to)
        if (PySequence_Check(pval) &amp;&amp; !PyUnicode_Check(pval)
            &amp;&amp; !PyBytes_Check(pval) &amp;&amp; !PyByteArray_Check(pval)) {
            PyObject* iter;
            PyObject* item;
            int i = 0;

            Py_ssize_t seq_size = PySequence_Length(pval);

            if ((iter = PyObject_GetIter(pval)) != NULL) {
                while ((item = PyIter_Next(iter)) != NULL) {
                    if (PyLong_Check(item)) {
                        long long_item = PyLong_AsLong(item);
                        py_log(x, "%d long: %ld\n", i, long_item);
                        i++;
                    }

                    if PyFloat_Check (item) {
                        float float_item = PyFloat_AsDouble(item);
                        py_log(x, "%d float: %f\n", i, float_item);
                        i++;
                    }

                    if PyUnicode_Check (item) {
                        const char* unicode_item = PyUnicode_AsUTF8(item);
                        py_log(x, "%d unicode: %s\n", i, unicode_item);
                        i++;
                    }
                    Py_DECREF(item);
                }
                py_log(x, "end iter op: %d", i);
            }

        }

        // cleanup
        Py_XDECREF(pval);
    }

    else {
        handle_py_error();
        // cleanup
        Py_XDECREF(pval);
    }
}

</t>
<t tx="sta.20200602170336.6">void py_exec(t_py* x, int argc, char* args)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;

    py_argv = atom_getsym(argv)-&gt;s_name;
    if (py_argv == NULL) {
        goto error;
    }

    pval = PyRun_String(py_argv, Py_single_input, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet0);

    // success cleanup
    Py_DECREF(pval);
    py_log(x, "exec %s", py_argv);
    return;

error:
    handle_py_error(x, "exec %s", py_argv);
    Py_XDECREF(pval);
}

</t>
<t tx="sta.20200602170336.7">void py_execfile(t_py* x, int argc, char* args)
{
    PyObject* pval = NULL;
    FILE* fhandle = NULL;

    if (s == gensym("")) {
        py_error(x, "py execfile: missing filepath");
        goto error;
    }

    fhandle = fopen(s-&gt;s_name, "r");
    if (fhandle == NULL) {
        py_error(x, "could not open file '%s'", s-&gt;s_name);
        goto error;
    }

    pval = PyRun_File(fhandle, s-&gt;s_name, Py_file_input, x-&gt;p_globals,
                      x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    outlet_bang(x-&gt;p_outlet0);

    // success cleanup
    fclose(fhandle);
    Py_DECREF(pval);
    py_log(x, "execfile %s", s-&gt;s_name);
    return;

error:
    handle_py_error(x, "execfile %s", s-&gt;s_name);
    Py_XDECREF(pval);
}

/*--------------------------------------------------------------------------*/
// extra python methods

</t>
<t tx="sta.20200602170336.8">void py_assign(t_py* x, int argc, char* args)
{
    char* varname = NULL;
    PyObject* list = NULL;

    if (s != gensym(""))
        py_log(x, "s: %s", s-&gt;s_name);

    // first atom in argv must be a symbol
    if (argv-&gt;a_type != A_SYM) {
        py_error(x, "first atom must be a symbol!");
        goto error;

    } else {
        // strncpy_zero(varname, atom_getsym(argv)-&gt;s_name, 50);
        varname = atom_getsym(argv)-&gt;s_name;
        py_log(x, "varname: %s", varname);
    }

    if ((list = PyList_New(0)) == NULL) {
        py_error(x, "list == NULL");
        goto error;
    }

    // NOTE: n C itâ€™s illegal to have a declaration as the first statement
    // after a label enclosing the whole subblock in a {} seems to work
    for (int i = 1; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                error("p_float == NULL");
                goto error;
            }
            PyList_Append(list, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(list, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(list, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(list) != argc - 1) {
        py_error(x, "PyList_Size(list) != argc - 1");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(list));
    }

    // finally, assign list to varname in object namespace
    py_log(x, "setting %s to list in namespace", varname);
    int res = PyDict_SetItemString(x-&gt;p_globals, varname, list);
    if (res != 0) {
        py_error(x, "assign varname to list failed");
        goto error;
    }
    // Py_XDECREF(list); // causes a crash
    return;

error:
    handle_py_error(x, "assign %s", s-&gt;s_name);
    Py_XDECREF(list);
}

</t>
<t tx="sta.20200602170336.9">void py_anything(t_py* x, int argc, char* args)
{
    char* py_argv = NULL;
    PyObject* pval = NULL;
    // PyObject* py_callable_str = NULL;
    PyObject* py_callable = NULL;
    PyObject* py_argslist = NULL; // python list
    PyObject* py_args = NULL;     // python tuple

    if (s == gensym("")) {
        py_error(x, "could not retrieve callable name", s-&gt;s_name);
        goto error;
    }

    py_callable = PyRun_String(s-&gt;s_name, Py_eval_input, x-&gt;p_globals,
                               x-&gt;p_globals);
    if (py_callable == NULL) {
        py_error(x, "could not evaluate '%s' as a python callable", s-&gt;s_name);
        goto error;
    }

    if ((py_argslist = PyList_New(0)) == NULL) {
        py_error(x, "could not create an empyt python list");
        goto error;
    }

    for (int i = 0; i &lt; argc; i++) {
        switch ((argv + i)-&gt;a_type) {
        case A_FLOAT: {
            double c_float = atom_getfloat(argv + i);
            PyObject* p_float = PyFloat_FromDouble(c_float);
            if (p_float == NULL) {
                py_error(x, "p_float == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_float);
            Py_DECREF(p_float);
            py_log(x, "%d: %f", i, atom_getfloat(argv + i));
            break;
        }
        case A_LONG: {
            PyObject* p_long = PyLong_FromLong(atom_getlong(argv + i));
            if (p_long == NULL) {
                py_error(x, "p_long == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_long);
            Py_DECREF(p_long);
            py_log(x, "%d: %ld", i, atom_getlong(argv + i));
            break;
        }
        case A_SYM: {
            PyObject* p_str = PyUnicode_FromString(
                atom_getsym(argv + i)-&gt;s_name);
            if (p_str == NULL) {
                py_error(x, "p_str == NULL");
                goto error;
            }
            PyList_Append(py_argslist, p_str);
            Py_DECREF(p_str);
            py_log(x, "%d: %s", i, atom_getsym(argv + i)-&gt;s_name);
            break;
        }
        default:
            py_log(x, "cannot process unknown type");
            break;
        }
    }

    if (PyList_Size(py_argslist) != argc) {
        py_error(x, "PyList_Size(list) != argc");
        goto error;
    } else {
        py_log(x, "length of list: %d", PyList_Size(py_argslist));
    }

    // convert py_args to tuple
    py_args = PyList_AsTuple(py_argslist);
    if (py_args == NULL) {
        py_error(x, "unable to convert args list to tuple");
        goto error;
    }

    pval = PyObject_Call(py_callable, py_args, NULL);
    if (pval == NULL) {
        py_error(x, "could not retrieve result of call");
        goto error;
    }

    // handle ints and longs
    if (PyLong_Check(pval)) {
        long int_result = PyLong_AsLong(pval);
        outlet_int(x-&gt;p_outlet1, int_result);
    }

    // handle floats and doubles
    if (PyFloat_Check(pval)) {
        float float_result = (float)PyFloat_AsDouble(pval);
        outlet_float(x-&gt;p_outlet1, float_result);
    }

    // handle strings
    if (PyUnicode_Check(pval)) {
        const char* unicode_result = PyUnicode_AsUTF8(pval);
        outlet_anything(x-&gt;p_outlet1, gensym(unicode_result), 0, NIL);
    }

    // handle lists, tuples and sets
    if (PyList_Check(pval) || PyTuple_Check(pval) || PyAnySet_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);
        if (seq_size &lt;= 0) {
            py_error(x,
                     "cannot convert python sequence with zero or less length "
                     "to atoms");
            goto error;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }
        outlet_list(x-&gt;p_outlet1, NULL, i, atoms);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }

    // success cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
    py_log(x, "END %s: %s", s-&gt;s_name, py_argv);
    return;

error:
    handle_py_error(x, "anythinh %s", s-&gt;s_name);
    // cleanup
    Py_XDECREF(py_callable);
    Py_XDECREF(py_argslist);
    Py_XDECREF(pval);
}
</t>
<t tx="sta.20200602170358.1">#include &lt;stdio.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170405.1">/*

Analysis finished in 314mss

No issues found

*/


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 20

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170419.1">/*

Analysis finished in 268mss

Found 3 issues

test_args.c:55: error: MEMORY_LEAK
  memory dynamically allocated by call to `malloc()` at line 52, column 25 is not reachable after line 55, column 9.
  53.
  54.       for(i = 1; i &lt;= size; i++) {
  55. &gt;         str = (char *)realloc(str, (v + strlen(argv[i])));
  56.           strcat(str, argv[i]);
  57.           strcat(str, " ");

test_args.c:60: error: MEMORY_LEAK
  memory dynamically allocated by call to `malloc()` at line 52, column 25 is not reachable after line 60, column 5.
  58.       }
  59.
  60. &gt;     printf("%s\n", str);
  61.       return 0;
  62.   }

test_args.c:56: error: NULL_DEREFERENCE
  pointer `str` last assigned on line 55 could be null and is dereferenced by call to `strcat()` at line 56, column 9.
  54.       for(i = 1; i &lt;= size; i++) {
  55.           str = (char *)realloc(str, (v + strlen(argv[i])));
  56. &gt;         strcat(str, argv[i]);
  57.           strcat(str, " ");
  58.       }


Summary of the reports

       MEMORY_LEAK: 2
  NULL_DEREFERENCE: 1

*/


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170439.1">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


char *foo(int count) {
    char *ret = malloc(count);
    if(!ret)
        return NULL;

    for(int i = 0; i &lt; count; ++i) 
        ret[i] = i;

    return ret;
}



void doit(char *buf, int count) {
    for(int i = 0; i &lt; count; ++i)
        buf[i] = i;
}


@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170448.1">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170456.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170502.1">@others
@language python
@tabwidth -4
</t>
<t tx="sta.20200602170513.1">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602170550.1">int main(int argc, char* argv[])
{
    PyObject *pName, *pModule, *pFunc;
    PyObject *pArgs, *pValue;
    int i;

    if (argc &lt; 3) {
        fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
        return 1;
    }

    Py_Initialize();
    pName = PyUnicode_DecodeFSDefault(argv[1]);
    /* Error checking of pName left out */

    pModule = PyImport_Import(pName);
    Py_DECREF(pName);

    if (pModule != NULL) {
        pFunc = PyObject_GetAttrString(pModule, argv[2]);
        /* pFunc is a new reference */

        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
            pArgs = PyTuple_New(argc - 3);
            for (i = 0; i &lt; argc - 3; ++i) {
                pValue = PyLong_FromLong(atoi(argv[i + 3]));
                if (!pValue) {
                    Py_DECREF(pArgs);
                    Py_DECREF(pModule);
                    fprintf(stderr, "Cannot convert argument\n");
                    return 1;
                }
                /* pValue reference stolen here: */
                PyTuple_SetItem(pArgs, i, pValue);
            }
            pValue = PyObject_CallObject(pFunc, pArgs);
            Py_DECREF(pArgs);
            if (pValue != NULL) {
                printf("Result of call: %ld\n", PyLong_AsLong(pValue));
                Py_DECREF(pValue);
            } else {
                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                PyErr_Print();
                fprintf(stderr, "Call failed\n");
                return 1;
            }
        } else {
            if (PyErr_Occurred())
                PyErr_Print();
            fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
        }
        Py_XDECREF(pFunc);
        Py_DECREF(pModule);
    } else {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
        return 1;
    }
    if (Py_FinalizeEx() &lt; 0) {
        return 120;
    }
    return 0;
}
</t>
<t tx="sta.20200602170553.1">import os

import pytest
from conftest import cwd, join

MODULES = ["os", "sys", "math"]

EXPRESSIONS = {
    "1+1": "int: 2",
    "2*10": "int: 20"
}

EVAL_FAIL = [
    # syntax errors
    "000000000000007",
    "000777", 
    "0777",
    "077787", 
    "090000000000000",
    "0b100e1", 
    "0b101j2", 
    "0e",
    "0o153j2", 
    "0o777e1", 
    "0x.", 
    "0xj", 
    "lambda a,a:0",
    "lambda a,a=1:0",
    "lambda a=1,a=1:0",
]

EVAL_EQUALS = [
    ("0xff", 255)
    ("0777.", 777)
    ("0777.0", 777)
    ("000000000000000000000000000000000000000000000000000777e0", 777)
    ("0777e1", 7770)
    ("0e0", 0)
    ("0000e-012", 0)
    ("09.5", 9.5)
    ("000", 0)
    ("00.0", 0)
    ("0e3", 0)
    ("090000000000000.", 90000000000000.)
    ("090000000000000.0000000000000000000000", 90000000000000.)
    ("090000000000000e0", 90000000000000.)
    ("090000000000000e-0", 90000000000000.)
    ("000000000000008.", 8.)
    ("000000000000009.", 9.)
    ("0b101010", 42)
    ("-0b000000000010", -2)
    ("0o777", 511)
    ("-0o0000010", -8)
]

EXEC_FAIL = [
    # syntax errors
    'def f(a, a): pass',
    'def f(a = 0, a = 1): pass',
    'def f(a): global a; a = 1',
    'def f(a=1, b): pass',
    'None = 0',
    'None += 0',
    '__builtins__.None = 0',
    'def None(): pass',
    'class None: pass',
    '(a, None) = 0, 0',
    'for None in range(10): pass',
    'def f(None): pass',
    'import None',
    'import x as None',
    'from x import None',
    'from x import y as None',
]

IMPORT_FAIL = [
    'import (os, sys)',
    'import (os), (sys)',
    'import ((os), (sys))',
    'import (sys',
    'import sys)',
    'import (os,)',
    'import os As bar',
    'import os.path a bar',
    'from sys import stdin As stdout',
    'from sys import stdin a stdout',
    'from (sys) import stdin',
    'from __future__ import (nested_scopes',
    'from __future__ import nested_scopes)',
    'from __future__ import nested_scopes,\ngenerators',
    'from sys import (stdin',
    'from sys import stdin)',
    'from sys import stdin, stdout,\nstderr',
    'from sys import stdin si',
    'from sys import stdin,',
    'from sys import (*)',
    'from sys import (stdin,, stdout, stderr)',
    'from sys import (stdin, stdout),',
    ]




IMPORT_SUCCEED = [
    'import sys',
    'import os, sys',
    'import os as bar',
    'import os.path as bar',
    'from __future__ import nested_scopes, generators',
    'from __future__ import (nested_scopes,\ngenerators)',
    'from __future__ import (nested_scopes,\ngenerators,)',
    'from sys import stdin, stderr, stdout',
    'from sys import (stdin, stderr,\nstdout)',
    'from sys import (stdin, stderr,\nstdout,)',
    'from sys import (stdin\n, stderr, stdout)',
    'from sys import (stdin\n, stderr, stdout,)',
    'from sys import stdin as si, stdout as so, stderr as se',
    'from sys import (stdin as si, stdout as so, stderr as se)',
    'from sys import (stdin as si, stdout as so, stderr as se,)',
    ]





</t>
<t tx="sta.20200602170553.2">@pytest.fixture(scope="module", params=MODULES)
def module(request):
    expr = request.param
    yield expr

</t>
<t tx="sta.20200602170553.3">@pytest.fixture(scope="module", params=EXPRESSIONS.keys())
def expression(request):
    mod = request.param
    yield mod



</t>
<t tx="sta.20200602170553.4">def test_import(capfd, module):
    arg = f'import {module}'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    assert captured.out == f"imported: {module}\n"


</t>
<t tx="sta.20200602170553.5">def test_import_error(capfd):
    arg = f'import hello'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    assert captured.out == f"PyException('{arg}'): Ooops again.\n"

</t>
<t tx="sta.20200602170553.6">def test_eval(capfd, expression):
    arg = f'eval {expression}'
    os.system(f'./tests/test_py {arg}')
    captured = capfd.readouterr()
    result = EXPRESSIONS[expression]
    assert captured.out == f"{result}\n"

</t>
<t tx="sta.20200602170556.1">int main(int argc, char *argv[]) {
    (void)argc;
    wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }
    Py_SetProgramName(program);
    Py_Initialize();
    PyRun_SimpleString(argv[1]);
    if (Py_FinalizeEx() &lt; 0) {
        exit(120);
    }
    PyMem_RawFree(program);
    return 0;
}
</t>
<t tx="sta.20200602170558.1">void printf2(char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

</t>
<t tx="sta.20200602170558.2">void sprintf2(char* buf, char* fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    vsprintf(buf, fmt, va);
    va_end(va);
}

</t>
<t tx="sta.20200602170558.3">void test_sprintf2(void)
{
    char buff[100];
    sprintf2(buff, "Hello, %s, aged %d", "Jo", 27);
    printf("%s\n", buff);
}

</t>
<t tx="sta.20200602170558.4">int main()
{
    printf("printf: hello %d\n", 1);
    printf2("printf2: hello %d\n", 1);
    test_sprintf2();
}
</t>
<t tx="sta.20200602170602.1">int main()
{
	char txt[10] = {0};
    char txt1[50] = "Hello World";
    char* txt2 = "World Hello";
    char** p_txt = &amp;txt2;
    doit(txt, 10);

    char *p = foo(10);
    if(p) {
        printf("p: %s length: %ld\n", p, strlen(p));
        free(p);
    }

    printf("txt1: %s length: %ld\n", txt1, strlen(txt1));
    printf("txt2: %s length: %ld\n", txt2, strlen(txt2));
    printf("p_txt: %s length: %ld\n", *p_txt, strlen(*p_txt));
    printf("txt: %s length: %ld\n", txt, strlen(txt));
}
</t>
<t tx="sta.20200602170604.1">int main(int argc, char *argv[]) {
    if(argc == 1) {
        printf("ERROR: Expected at least 1 argument\n");
        return 0;
    }

    int i, v = 0, size = argc - 1;

    char *str = (char *)malloc(v);

    for(i = 1; i &lt;= size; i++) {
        str = (char *)realloc(str, (v + strlen(argv[i])));
        strcat(str, argv[i]);
        strcat(str, " ");
    }

    printf("%s\n", str);
    return 0;
}
</t>
<t tx="sta.20200602170608.1">int main(int argc, char *argv[]) {

    char buffer[BUFFER_SIZE];
    int total_input_length = 0;

    if(argc == 1) {
        printf("ERROR: Expected at least 1 argument\n");
        return 0;
    }

    for (int i=1; i &lt;= argc-1; i++) {
        total_input_length += strlen(argv[i]);
    }

    if (total_input_length &gt; BUFFER_SIZE-1) {
        printf("input length of %d &gt; available buffer length of %d by %d characters.\n",
        total_input_length, BUFFER_SIZE-1, total_input_length - (BUFFER_SIZE-1));
        exit(1);
    }

    // copy first
    strncpy(buffer, argv[1], BUFFER_SIZE-1);
    buffer[BUFFER_SIZE-1] = '\0';

    for(int i = 2; i &lt;= argc-1; i++) {
        printf("%d.1 strlen(buffer): %ld\n", i, strlen(buffer));
        strncat(buffer, " ", BUFFER_SIZE - strlen(buffer) - 1);
        printf("%d.2 strlen(buffer): %ld\n", i, strlen(buffer));
        strncat(buffer, argv[i], BUFFER_SIZE - strlen(buffer) - 1);
    }

    printf("final strlen(buffer): %ld\n", strlen(buffer));
    printf("%s\n", buffer);
    return 0;
}
</t>
<t tx="sta.20200602170611.1">int main()
{
    int x = 10;
    // fall through with no return!

hello:
    x++;
    printf("hello: %d\n", x);

bye:
    x++;
    printf("bye: %d\n", x);

    return 0;
}
</t>
<t tx="sta.20200602174033.1">#include &lt;stdio.h&gt;

#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;compile.h&gt;
#include &lt;eval.h&gt;
#include &lt;object.h&gt;

#include "readline.h"

int add_history(char*);

@others
@language c
@tabwidth -4
</t>
<t tx="sta.20200602174134.1">int main(int argc, char* argv[])
{
    int i, j, done = 0; /* lengths of line, code */
    char ps1[] = "&gt;&gt;&gt; ";
    char ps2[] = "... ";
    char* prompt = ps1;
    char *msg, *line, *code = NULL;
    PyObject *src, *glb, *loc;
    PyObject *exc, *val, *trb, *obj, *dum;

    Py_Initialize();
    loc = PyDict_New();
    glb = PyDict_New();
    PyDict_SetItemString(glb, "__builtins__", PyEval_GetBuiltins());

    while (!done) {
        line = readline(prompt);

        if (NULL == line) /* Ctrl-D pressed */
        {
            done = 1;
        } else {
            i = strlen(line);

            if (i &gt; 0)
                add_history(line); /* save non-empty lines */

            if (NULL == code) /* nothing in code yet */
                j = 0;
            else
                j = strlen(code);

            code = realloc(code, i + j + 2);
            if (NULL == code) /* out of memory */
                exit(1);

            if (0 == j)         /* code was empty, so */
                code[0] = '\0'; /* keep strncat happy */

            strncat(code, line, i); /* append line to code */
            code[i + j] = '\n';     /* append '\n' to code */
            code[i + j + 1] = '\0';

            src = Py_CompileString(code, "&lt;stdin&gt;", Py_single_input);

            if (NULL != src) /* compiled just fine - */
            {
                if (ps1 == prompt ||         /* "&gt;&gt;&gt; " or */
                    '\n' == code[i + j - 1]) /* "... " and double '\n' */
                {                            /* so execute it */
                    dum = PyEval_EvalCode(src, glb, loc);
                    Py_XDECREF(dum);
                    Py_XDECREF(src);
                    free(code);
                    code = NULL;
                    if (PyErr_Occurred())
                        PyErr_Print();
                    prompt = ps1;
                }
            } /* syntax error or E_EOF? */
            else if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
                PyErr_Fetch(&amp;exc, &amp;val, &amp;trb); /* clears exception! */

                if (PyArg_ParseTuple(val, "sO", &amp;msg, &amp;obj)
                    &amp;&amp; !strcmp(msg,
                               "unexpected EOF while parsing")) /* E_EOF */
                {
                    Py_XDECREF(exc);
                    Py_XDECREF(val);
                    Py_XDECREF(trb);
                    prompt = ps2;
                } else /* some other syntax error */
                {
                    PyErr_Restore(exc, val, trb);
                    PyErr_Print();
                    free(code);
                    code = NULL;
                    prompt = ps1;
                }
            } else /* some non-syntax error */
            {
                PyErr_Print();
                free(code);
                code = NULL;
                prompt = ps1;
            }

            free(line);
        }
    }

    Py_XDECREF(glb);
    Py_XDECREF(loc);
    Py_Finalize();
    exit(0);
}
</t>
<t tx="sta.20200603072826.1">long py_scan_callback(t_py* x, t_object* box)
{
    t_rect jr;
    t_object* p;
    t_symbol* s;
    t_symbol* varname;
    t_object* obj;
    t_symbol* obj_id;

    jbox_get_patching_rect(box, &amp;jr);
    p = jbox_get_patcher(box);
    varname = jbox_get_varname(box);
    obj = jbox_get_object(box);

    // lifted from scheme-for-max (Thanks, Iain!)
    if (varname != gensym("")) {
        py_log(x, "storing object '%s' in the global registry",
               varname-&gt;s_name);
        hashtab_store(py_global_registry, varname, obj);
    }

    obj_id = jbox_get_id(box);
    s = jpatcher_get_name(p);
    object_post(
        (t_object*)x,
        "in patcher:%s, varname:%s id:%s box @ x %ld y %ld, w %ld, h %ld",
        s-&gt;s_name, varname-&gt;s_name, obj_id-&gt;s_name, (long)jr.x, (long)jr.y,
        (long)jr.width, (long)jr.height);
    return 0;
}

</t>
<t tx="sta.20200605120205.1">void py_locatefile(t_py* x, char* filename)
{
    // works for folders as well
    char name[MAX_FILENAME_CHARS];
    short path;
    t_fourcc type;

    char pathname[MAX_PATH_CHARS];
    short err;

    if (filename == NULL)
        return;

    strncpy_zero(name, filename, MAX_FILENAME_CHARS);

    if (locatefile_extended(name, &amp;path, &amp;type, NULL, 0)) {
        error("path %s not found", name);
    } else {
        post("path %s, path %d", name, path);
        err = path_topathname(path, name, pathname);
        if (err == 0) {
            post("absolute path: %s", pathname);
        }
    }
}
</t>
<t tx="sta.20200605120324.1">void py_call(t_py* x, t_symbol* s, long argc, t_atom* argv)
{
    long textsize = 0;
    char* text = NULL;
    PyObject* co = NULL;
    PyObject* pval = NULL;
    t_max_err err;
    int is_eval = 1;

    err = atom_gettext(argc, argv, &amp;textsize, &amp;text,
                       OBEX_UTIL_ATOM_GETTEXT_DEFAULT);
    if (err == MAX_ERR_NONE &amp;&amp; textsize &amp;&amp; text) {
        py_log(x, "call %s", text);
    } else {
        goto error;
    }

    co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_eval_input);

    if (PyErr_ExceptionMatches(PyExc_SyntaxError)) {
        PyErr_Clear();
        co = Py_CompileString(text, x-&gt;p_name-&gt;s_name, Py_single_input);
        is_eval = 0;
    }

    if (co == NULL) { // can be eval-co or exec-co or NULL here
        goto error;
    }
    sysmem_freeptr(text);

    pval = PyEval_EvalCode(co, x-&gt;p_globals, x-&gt;p_globals);
    if (pval == NULL) {
        goto error;
    }
    Py_DECREF(co);

    if (!is_eval) {
        // bang for exec-type op
        outlet_bang(x-&gt;p_outlet_right);
    } else {
        py_handle_output(x, pval);
    }
    return;

error:
    py_handle_error(x, "call failed");
    // fail bang
    outlet_bang(x-&gt;p_outlet_middle);
}

</t>
<t tx="sta.20200606044751.1">void py_handle_output(t_py* x, PyObject* pval)
{

    // handle ints and longs
    if (PyLong_Check(pval)) {
        long int_result = PyLong_AsLong(pval);
        outlet_int(x-&gt;p_outlet_left, int_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle floats and doubles
    if (PyFloat_Check(pval)) {
        float float_result = (float)PyFloat_AsDouble(pval);
        outlet_float(x-&gt;p_outlet_left, float_result);
        outlet_bang(x-&gt;p_outlet_right);
    }

    // handle strings
    if (PyUnicode_Check(pval)) {
        const char* unicode_result = PyUnicode_AsUTF8(pval);
        outlet_anything(x-&gt;p_outlet_left, gensym(unicode_result), 0, NIL);
        outlet_bang(x-&gt;p_outlet_right);
    }

    /* handle any sequence except strings, and presently
       bytes and byte arrays (until there is a reason to)
    */
    if (PySequence_Check(pval) &amp;&amp; !PyUnicode_Check(pval)
        &amp;&amp; !PyBytes_Check(pval) &amp;&amp; !PyByteArray_Check(pval)) {
        PyObject* iter = NULL;
        PyObject* item = NULL;
        int i = 0;

        t_atom atoms_static[PY_MAX_ATOMS];
        t_atom* atoms = NULL;
        int is_dynamic = 0;

        Py_ssize_t seq_size = PySequence_Length(pval);

        if (seq_size &lt;= 0) {
            py_error(x, 
                "cannot convert python sequence with length &lt;= 0 to atoms");
            goto error;
        }

        if (seq_size &gt; PY_MAX_ATOMS) {
            py_log(x, "dynamically increasing size of atom array");
            atoms = atom_dynamic_start(atoms_static, PY_MAX_ATOMS,
                                       seq_size + 1);
            is_dynamic = 1;

        } else {
            atoms = atoms_static;
        }

        if ((iter = PyObject_GetIter(pval)) == NULL) {
            goto error;
        }

        while ((item = PyIter_Next(iter)) != NULL) {
            if (PyLong_Check(item)) {
                long long_item = PyLong_AsLong(item);
                atom_setlong(atoms + i, long_item);
                py_log(x, "%d long: %ld\n", i, long_item);
                i++;
            }

            if PyFloat_Check (item) {
                float float_item = PyFloat_AsDouble(item);
                atom_setfloat(atoms + i, float_item);
                py_log(x, "%d float: %f\n", i, float_item);
                i++;
            }

            if PyUnicode_Check (item) {
                const char* unicode_item = PyUnicode_AsUTF8(item);
                py_log(x, "%d unicode: %s\n", i, unicode_item);
                atom_setsym(atoms + i, gensym(unicode_item));
                i++;
            }
            Py_DECREF(item);
        }

        outlet_list(x-&gt;p_outlet_left, NULL, i, atoms);
        outlet_bang(x-&gt;p_outlet_right);
        py_log(x, "end iter op: %d", i);

        if (is_dynamic) {
            py_log(x, "restoring to static atom array");
            atom_dynamic_end(atoms_static, atoms);
        }
    }
    // final cleanup
    Py_XDECREF(pval);
    return;

error:
    py_handle_error(x, "python exception occurred");
    Py_XDECREF(pval);
    outlet_bang(x-&gt;p_outlet_middle);
}
</t>
<t tx="sta.20200606073716.1"></t>
</tnodes>
</leo_file>
