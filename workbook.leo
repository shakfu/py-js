<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070622214401"><vh>Startup</vh>
<v t="ekr.20060112110750"><vh>Local buttons</vh>
<v t="ekr.20111006212449.11850"><vh>@button check-settings</vh>
<v t="ekr.20111006212449.11851"><vh>ctor</vh></v>
<v t="ekr.20111006212449.11852"><vh>check &amp; helpers</vh>
<v t="ekr.20181018060340.1"><vh>filter_get_x</vh></v>
<v t="ekr.20181018065113.1"><vh>filter_user_config</vh></v>
</v>
<v t="ekr.20200226105416.1"><vh>check_user_settings</vh></v>
<v t="ekr.20111006212449.11853"><vh>error</vh></v>
<v t="ekr.20111006212449.11854"><vh>get_commanders</vh></v>
<v t="ekr.20111006212449.11855"><vh>get_configs &amp; helpers</vh>
<v t="ekr.20111006212449.11856"><vh>get_configs_from_outline &amp; helper</vh>
<v t="ekr.20111006212449.11857"><vh>scan_for_configs</vh></v>
</v>
</v>
<v t="ekr.20111006212449.11858"><vh>get_settings &amp; helper</vh>
<v t="ekr.20111006212449.11859"><vh>is_setting</vh></v>
<v t="ekr.20111006212449.11860"><vh>parse_setting</vh></v>
</v>
<v t="ekr.20111006212449.11861"><vh>munge</vh></v>
<v t="ekr.20111006212449.11862"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20111026083456.16490"><vh>Local commands</vh>
<v t="ekr.20111026083456.16491"><vh>@command print-all-plugins</vh></v>
</v>
<v t="ekr.20190324182659.1"><vh>script: make color nodes</vh></v>
<v t="sta.20240722203753.1"><vh>@settings</vh>
<v t="ekr.20140912075503.19263"><vh>@string font-family = Monaco, Droid Sans Mono</vh></v>
<v t="ekr.20140912075503.19264"><vh>@string font-size = 12pt </vh></v>
<v t="ekr.20140915194122.23413"><vh>@string medium-font-size = 10pt</vh></v>
<v t="ekr.20140915194122.21837"><vh>@string small-font-size = 10pt</vh></v>
<v t="ekr.20140912075503.19266"><vh>@string font-style = normal</vh></v>
<v t="ekr.20140912075503.19265"><vh>@string font-weight = normal</vh></v>
</v>
</v>
<v t="sta.20240722204640.1"><vh>src</vh>
<v t="sta.20241211203746.1"><vh>projects</vh>
<v t="sta.20241211203834.1"><vh>py</vh>
<v t="sta.20241211203909.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206090014.1"><vh>@auto py.c</vh></v>
<v t="sta.20250206092311.1"><vh>@auto py.h</vh></v>
</v>
<v t="sta.20241211203934.1"><vh>pyjs</vh>
<v t="sta.20241211203950.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206091726.1"><vh>@auto pyjs.c</vh></v>
<v t="sta.20250206135316.1"><vh>@auto pyjs.h</vh></v>
</v>
<v t="sta.20250130115409.1"><vh>cobra</vh>
<v t="sta.20250130115509.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206091745.1"><vh>@auto cobra.c</vh></v>
</v>
<v t="sta.20250130115618.1"><vh>cmx</vh>
<v t="sta.20250130120008.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206091823.1"><vh>@auto cmx.c</vh></v>
</v>
<v t="sta.20250130115728.1"><vh>demo</vh>
<v t="sta.20250130120029.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206091847.1"><vh>@auto demo.c</vh></v>
</v>
<v t="sta.20250130115623.1"><vh>jmx</vh>
<v t="sta.20250130120047.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206091858.1"><vh>@auto jmx.c</vh></v>
</v>
<v t="sta.20250130115630.1"><vh>krait</vh>
<v t="sta.20250130120100.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206092000.1"><vh>@auto krait.cpp</vh></v>
<v t="sta.20250206092026.1"><vh>@auto py_interpreter.h</vh></v>
</v>
<v t="sta.20250130120441.1"><vh>mamba</vh>
<v t="sta.20250130120448.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206092058.1"><vh>@auto mamba.c</vh></v>
<v t="sta.20250206092113.1"><vh>@auto py.h</vh></v>
</v>
<v t="sta.20250130115634.1"><vh>mxpy</vh>
<v t="sta.20250130120106.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206092137.1"><vh>@auto mxpy.c</vh></v>
</v>
<v t="sta.20250130115638.1"><vh>pktpy</vh>
<v t="sta.20250130120112.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206135449.1"><vh>@auto pktpy.cpp</vh></v>
<v t="sta.20250206092152.1"><vh>@auto pktpy.h</vh></v>
</v>
<v t="sta.20250130115644.1"><vh>shell</vh>
<v t="sta.20250130120117.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206092253.1"><vh>@auto shell.cpp</vh></v>
</v>
<v t="sta.20250130115707.1"><vh>zedit</vh>
<v t="sta.20250130120124.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206135550.1"><vh>@auto zedit.c</vh></v>
</v>
<v t="sta.20250130115713.1"><vh>zpy</vh>
<v t="sta.20250130120129.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206135613.1"><vh>@auto zpy.c</vh></v>
</v>
<v t="sta.20250130115716.1"><vh>zthread</vh>
<v t="sta.20250130120133.1"><vh>@auto-md README.md</vh></v>
<v t="sta.20250206135629.1"><vh>@auto zthread.c</vh></v>
</v>
</v>
<v t="sta.20240722212036.1"><vh>@auto-md README.md</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20060112110750">@language python</t>
<t tx="ekr.20070622214401">@nocolor-node

Please don't change this node and its descendants; they are for Leo's
developers.
</t>
<t tx="ekr.20111006212449.11850">'''Check the consistency of all settings.'''
# https://github.com/leo-editor/leo-editor/issues/993
# https://github.com/leo-editor/leo-editor/issues/1511

class Controller:
    @others

g.cls()
Controller(c).run()
</t>
<t tx="ekr.20111006212449.11851">def __init__(self, c):
    self.c = c
    self.errors = 0
    # Commanders...
    self.core = None  # leoPy.leo.
    self.settings = None  # leoSettings.leo.
    self.user_settings = None  # myLeoSettings.leo
</t>
<t tx="ekr.20111006212449.11852">def check(self, configs_d, settings_d):
    munge = self.munge
    table = ('Bool', 'Int', 'Float', 'Ratio', 'Path', 'String',) # 'Color', 'Font',
    
    def printList(aList):
        if len(aList) &lt; 2:
            print('  ', aList[0])
        else:
            g.printObj(aList)
    #
    # Print missing user settings...
    for kind in table:
        config_key = 'get%s' % kind
        settings_key = '@%s' % kind.lower()
        configs = configs_d.get(config_key, [])
        settings = settings_d.get(settings_key, [])
        m_configs = [munge(z) for z in configs]
        m_settings = [munge(z) for z in settings]
        missing = set([z for z in m_configs if not z in m_settings])
        aList = [z for z in missing if self.filter_user_config(z)]
        if aList:
            print('\nmissing %s %s settings...\n' % (len(aList), settings_key))
            for z in sorted(aList):
                aList2 = [z2 for z2 in configs if munge(z2) == munge(z)]
                printList(aList2)
    #
    # Print missing calls to c.config.getX...
    for kind in table:
        config_key = 'get%s' % kind
        settings_key = '@%s' % kind.lower()
        configs = configs_d.get(config_key, [])
        settings = settings_d.get(settings_key, [])
        m_configs = [munge(z) for z in configs]
        m_settings = [munge(z) for z in settings]
        missing = set([z for z in m_settings if not z in m_configs])
        aList = [z for z in missing if self.filter_get_x(z)]
        if aList:
            print(f"missing {len(aList)} config.{config_key} calls:")
            for z in sorted(aList):
                aList2 = [z2 for z2 in settings if munge(z2) == munge(z)]
                printList(aList2)</t>
<t tx="ekr.20111006212449.11853">def error(self, s):
    print(s)
    self.errors += 1
</t>
<t tx="ekr.20111006212449.11854">def get_commanders(self):
    '''Open files as needed and set the commander ivars.'''

    def open_commander(fn):
        c = g.openWithFileName(fn, old_c=self.c, gui=g.app.nullGui)
        if not c:
            self.error('not found: %s' % fn)
        return c

    join, loadDir = g.os_path_join, g.app.loadDir
    self.core = open_commander(join(loadDir, '..', 'core', 'leoPy.leo'))
        # Opening LeoPyRef.leo would be slower.
    self.settings = open_commander(join(loadDir, '..', 'config', 'leoSettings.leo'))
    self.user_settings = open_commander(g.app.loadManager.my_settings_path)
</t>
<t tx="ekr.20111006212449.11855">def get_configs(self):
    '''
    Return a dict containing a representation of all calls to x.config.getX.
    '''
    d = {}
    for c in (self.core, ):
        print('scanning: %s' % c.shortFileName())
        self.get_configs_from_outline(c, d)
    return d
</t>
<t tx="ekr.20111006212449.11856">def get_configs_from_outline(self, c, d):
    '''
    Scan the outline for all calls to x.config.getX and add items to d.
    '''
    p = c.rootPosition()
    while p:
        if '@nosearch' in p.b:  # #1511.
            # print('ignore', p.h)
            p.moveToNodeAfterTree()
        else:
            self.scan_for_configs(p, d)
            p.moveToThreadNext()
    return d
</t>
<t tx="ekr.20111006212449.11857">def scan_for_configs(self, p, d):
    '''
    Scan the body text of p, finding all calls to config.getX.
    
    This code does not know about `if 0`, but does know about comments.
    '''
    kinds = (
        'getBool', 'getColor', 'getInt', 'getFloat',
        'getPath', 'getRatio', 'getString',
        # '@font', # special case.
    )
    i, s = 0, p.b
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if (
            ch == '@' and
            (g.match(s, i, '@ ') or g.match(s, i, '@\n')) and
            (i == 0 or s[i - 1] == '\n')
        ):
            # Skip the @doc part.
            i = s.find('\n@c', i)
            if i == -1: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s, i)
        elif ch in ('"', "'"):
            i = g.skip_python_string(s, i)
        elif ch == '_' or ch.isalpha():
            j = g.skip_id(s, i)
            kind = s[i: j]
            if kind in kinds:
                # We have found a call to getBool, etc.
                i = g.skip_ws(s, j)
                if g.match(s, i, '('):
                    i = g.skip_ws_and_nl(s, i + 1)  # #1511.
                    if g.match(s, i, '"') or g.match(s, i, "'"):
                        j = g.skip_string(s, i)
                        name = s[i + 1: j - 1]
                        # print(f"{kind:12} {name}")
                        aList = d.get(kind, [])
                        if name not in aList:
                            aList.append(name)
                        d[kind] = aList
                else:
                    j = i
            i = j
        else:
            i += 1
        assert progress &lt; i
    return d
</t>
<t tx="ekr.20111006212449.11858">def get_settings(self, user):
    '''Return a dict containing a representation
    of all settings in leoSettings.leo or myLeoSettings.leo.
    '''
    trace = False
    c = self.user_settings if user else self.settings  # #1511.
    d = {}
    print('scanning: %s' % c.shortFileName())
    # #1792: Allow comments after @settings.
    settings_node = g.findNodeAnywhere(c, '@settings', exact=False)
    if not settings_node:
        return self.error('no @settings node')
    for p in settings_node.subtree():
        if self.is_setting(p):
            kind, name = self.parse_setting(p)
            if name:
                # name = self.munge(name)
                aList = d.get(kind, [])
                if name not in aList:
                    aList.append(name)
                d[kind] = aList
            else:
                self.error('no name for %s' % (kind))
    if trace:
        keys = list(d.keys())
        for key in sorted(keys):
            print(key)
            aList = d.get(key)
            for name in sorted(aList):
                print('  ' + name)
    return d
</t>
<t tx="ekr.20111006212449.11859">def is_setting(self, p):
    # For now, these are enough
    table = (
        '@bool', '@color', '@int', '@float',
        # '@font', # special case.
        '@ratio', '@path', '@string',
    )
    for s in table:
        if g.match_word(p.h, 0, s):
            return True
    return False
</t>
<t tx="ekr.20111006212449.11860">def parse_setting(self, p):
    s = p.h
    assert s[0] == '@'
    i = g.skip_id(s, 1)
    kind = s[: i]
    assert kind
    i = g.skip_ws(s, i)
    j = g.skip_id(s, i, chars='-')
    name = s[i: j]
    return kind, name
</t>
<t tx="ekr.20111006212449.11861">def munge(self, s):
    '''Return the canonicalized name for settings and arguments to c.config.getX.'''
    return g.toUnicode(s.replace('-', '').replace('_', '').lower())
</t>
<t tx="ekr.20111006212449.11862">def run(self):
    self.get_commanders()
    configs = self.get_configs()
    settings = self.get_settings(user=False)
    user_settings = self.get_settings(user=True)
    if self.errors == 0:
        self.check(configs, settings)
        self.check_user_settings(settings, user_settings)
    # Select leoSettings.leo.
    g.app.gui.frameFactory.setTabForCommander(self.settings)
    g.trace('done')
</t>
<t tx="ekr.20111026083456.16490">@language python</t>
<t tx="ekr.20111026083456.16491">import glob

path = g.os_path_finalize_join(
    g.app.loadDir,'..','plugins','*.py')

aList = glob.glob(path)
aList.sort()

for fn in aList:
    print(g.shortFileName(fn))</t>
<t tx="ekr.20140912075503.19263"></t>
<t tx="ekr.20140912075503.19264">**Important**: This should be set by each user.</t>
<t tx="ekr.20140912075503.19265">valid values are: normal,bold,100,..,900</t>
<t tx="ekr.20140912075503.19266">Valid values are: normal,italic,oblique</t>
<t tx="ekr.20140915194122.21837">A small font size used by default in the status area.</t>
<t tx="ekr.20140915194122.23413">A small font size used by default in the check boxes in the Find tab.</t>
<t tx="ekr.20181018060340.1">def filter_get_x(self, setting):
    '''
    Return False if we can safely ignore a missing call to config.get(setting).
    
    Everything here is a hack. Some are bigger than others.
    '''
    munge = self.munge
    #
    # These *ivars* are set by the GlobalConfigManager class.
    # There *should* be settings for all of these, despite missing config.get calls.
    table = (
        # encodingIvarsDict...
            "default_at_auto_file_encoding",
            "default_derived_file_encoding",
            "new_leo_file_encoding",
        # defaultsDict...
            "color_directives_in_plain_text",
            "output_doc_chunks",
            "page_width",
            "tab_width",
            "tangle_outputs_header",
            "target_language",
            "underline_undefined_section_names",
        # ivarsDict
            "at_root_bodies_start_in_doc_mode",
            "create_nonexistent_directories",
            "output_initial_comment",
            "output_newline",
            "page_width",
            "read_only",
            "redirect_execute_script_output_to_log_pane",
            "relative_path_base_directory",
            "remove_sentinels_extension",
            "save_clears_undo_buffer",
            "stylesheet",
            "tab_width",
            "target_language",
            "trailing_body_newlines",
            "use_plugins",
            "undo_granularity",
            "write_strips_blank_lines",
    )
    table = [munge(z) for z in table]
    if setting in table:
        return False
    #
    # unitTest.leo tests test-darwin-setting and test-win32-setting
    if setting in ('testdarwinsetting', 'testwin32setting'):
        return False
    #
    # Stylesheets use these settings.
    for pattern in (
        'bg', 'border', 'color', 'fg', 'font',
        'leogreen', 'leoyello',
        'margin', 'padding', 'relief',
        'solarized', 'split-bar', 'text-foreground', 'tree-image',
    ):
        if setting.find(munge(pattern)) &gt; -1:
            return False
    #
    # These plugins/use settings in non-standard ways.
    if setting.startswith((
            'bookmarks', 'datenodes', 'http', 'opml',
            'rst3', 'todo', 'vim', 'zodb'
        ),
    ):
        return False
    #
    # Find settings are defined in non-standard ways.
    for pattern in (
        'batch', 'change-text',
        'find-def-creates-clones',
        'find-text', 'ignore-case',
        'mark-changes', 'mark-finds', 'node-only', 'pattern-match',
        'reverse', 'search-body', 'search-headline', 'suboutline-only',
        'whole-word', 'wrap',
    ):
        if setting == munge(pattern):
            return False
    #
    # Issue a warning.
    return True
</t>
<t tx="ekr.20181018065113.1">def filter_user_config(self, setting):
    '''
    Return False if we can safely ignore a setting that does not exist in leoSettings.leo.
    
    Everything here is a hack. Some are bigger than others.
    '''
    munge = self.munge
    #
    # unitTest.leo tests test-darwin-setting and test-win32-setting
    if setting in ('testdarwinsetting', 'testwin32setting'):
        return False
    #
    # The calls to config.get* are commented out in the code,
    # but get_configs isn't smart enough to know that.
    for ignore in (
        'theme-name',
        'pytest-path', # In a (disabled) @button node
        'leo-to-html-%s', # Loads multiple settings from an .ini file.
    ):
        if setting == munge(ignore):
            return False
    #
    # Stylesheets use these settings.
    # It would be a major project to discover what settings
    # are actually used in the present stylesheet.
    for pattern in (
        'bg', 'border', 'color', 'fg', 'font',
        'leogreen', 'leoyello',
        'margin', 'padding', 'relief',
        'solarized', 'split-bar', 'text-foreground', 'tree-image',
    ):
        if munge(pattern) in setting:
            return False
    #
    # These plugins use settings in non-standard ways.
    if setting.startswith((
        'activepath', 'bookmarks', 'datenodes', 'http', 'opml',
        'rst3', 'todo', 'vim', 'vr3', 'zodb'),
    ):
        return False
    #
    # Find settings are defined in non-standard ways.
    for pattern in (
        'batch', 'change-text', 'find-text', 'ignore-case',
        'mark-changes', 'mark-finds', 'node-only', 'pattern-match',
        'reverse', 'search-body', 'search-headline', 'suboutline-only',
        'whole-word', 'wrap',
    ):
        if setting == munge(pattern):
            return False
    #
    # Tangle/untagle settings are deprecated and imo should not exist.
    for pattern in (
        'output-doc-flag', 'tangle-batch-flag',
        'untangle-batch-flag', 'use-header-flag',
    ):
        if setting == munge(pattern):
            return False
    #
    # Issue a warning.
    return True
</t>
<t tx="ekr.20190324182659.1">@language python

from  leo.core.leoColor import leo_color_database as color_d

d = {
    'Comment':            'solarized-orange',
    'Comment.Single':     'solarized-orange',
    'Generic.Deleted':    'solarized-red',
    'Generic.Emph':       'solarized-blue',
    'Generic.Heading':    'solarized-magenta',
    'Generic.Inserted':   'alt-solarized-green',
    'Generic.Strong':     'solarized-blue',
    'Generic.Subheading': 'solarized-magenta',
    'Keyword':            'solarized-blue',
    'Name':               'white',
    'Name.Class':         'white',
    'Name.Decorator':     'solarized-orange',
    'Name.Entity':        'solarized-blue',
    'Name.Function':      'white',
    'Name.Other':         'solarized-red',
    'Name.Tag':           'solarized-magenta',
    'String':             'alt-solarized-green',
    'String.Doc':         'solarized-orange', # docstring.
    'String.Double':      'alt-solarized-green',
    'String.Interpol':    'alt-solarized-green',
    'String.Single':      'alt-solarized-green',
}
root = p.copy()
for key, val in d.items():
    p = root.insertAsLastChild()
    # p.h = '@color %s = %s' % (key.lower(), color_d.get(val, 'white'))
    p.h = '@color %s = %s' % (key.lower(), val)
    # p.b = val
c.redraw()
    </t>
<t tx="ekr.20200226105416.1">def check_user_settings(self, settings_d, user_settings_d):
    """
    Report settings in myLeoSettings.leo that are not in leoSettings.leo.
    
    This method requires exact matches between settings: it does no munging.
    """
    unusual_keys = (
        '@color',  # per-key @color settings have changed.
    )
    unusual_settings = (
        # 'forth',  # Experimental.
        'color-theme',  # Uses td.get_string_setting.
        'theme-name',  # Uses td.get_string_setting.
    )
    for key in user_settings_d:
        settings = settings_d.get(key, [])
        user_settings = user_settings_d.get(key, [])
        for user_setting in user_settings:
            if (
                user_setting not in settings
                and user_setting not in unusual_settings
                and key not in unusual_keys
            ):
                print(f"Unknown setting in myLeoSettings.leo: {key} {user_setting}")
</t>
<t tx="sta.20240722203753.1"></t>
<t tx="sta.20240722204640.1"></t>
<t tx="sta.20241211203746.1">@path source/projects</t>
<t tx="sta.20241211203834.1">@path py
</t>
<t tx="sta.20241211203934.1">@path pyjs
</t>
<t tx="sta.20250130115409.1">@path cobra
</t>
<t tx="sta.20250130115618.1">@path cmx
</t>
<t tx="sta.20250130115623.1">@path jmx
</t>
<t tx="sta.20250130115630.1">@path krait
</t>
<t tx="sta.20250130115634.1">@path mxpy
</t>
<t tx="sta.20250130115638.1">@path pktpy
</t>
<t tx="sta.20250130115644.1">@path shell
</t>
<t tx="sta.20250130115707.1">@path zedit
</t>
<t tx="sta.20250130115713.1">@path zpy
</t>
<t tx="sta.20250130115716.1">@path zthread
</t>
<t tx="sta.20250130115728.1">@path demo
</t>
<t tx="sta.20250130120441.1">@path mamba
</t>
</tnodes>
</leo_file>
